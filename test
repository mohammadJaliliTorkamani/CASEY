File: app/models/pusher.rb
Methods:
<Method>
def validate
    signature_missing = "There was a problem saving your gem: \nYou have added cert_chain in gemspec but signature was empty"

    return notify(signature_missing, 403) unless validate_signature_exists?
    (rubygem.valid? && version.valid?) || notify("There was a problem saving your gem: #{rubygem.all_errors(version)}", 403)
  end
</Method>
<Method>
def validate
    signature_missing = "There was a problem saving your gem: \nYou have added cert_chain in gemspec but signature was empty"

    return notify(signature_missing, 403) unless validate_signature_exists?
    (rubygem.valid? && version.valid?) || notify("There was a problem saving your gem: #{rubygem.all_errors(version)}", 403)
  end
</Method>
<Method>
def validate
    signature_missing = "There was a problem saving your gem: \nYou have added cert_chain in gemspec but signature was empty"

    return notify(signature_missing, 403) unless validate_signature_exists?
    (rubygem.valid? && version.valid?) || notify("There was a problem saving your gem: #{rubygem.all_errors(version)}", 403)
  end
</Method>
<Method>
def write_gem(body, spec)
    original_name = spec.original_name

    gem_path = "gems/#{original_name}.gem"
    gem_contents = body.string

    spec.abbreviate
    spec.sanitize
    spec_path = "quick/Marshal.4.8/#{original_name}.gemspec.rz"
    spec_contents = Gem.deflate(Marshal.dump(spec))

    spec_contents_checksum = Digest::SHA2.base64digest(spec_contents)

    # do all processing _before_ we upload anything to S3, so we lower the chances of orphaned files
    RubygemFs.instance.store(gem_path, gem_contents, checksum_sha256: version.sha256)
    RubygemFs.instance.store(spec_path, spec_contents, checksum_sha256: spec_contents_checksum)

    Fastly.purge(path: gem_path)
    Fastly.purge(path: spec_path)
  end
</Method>
File: app/models/specification_policy.rb
Methods:
File: app/models/version.rb
Methods:
File: lib/patterns.rb
Methods:
File: test/helpers/gem_helpers.rb
Methods:
<Method>
def gem_specification_from_gem_fixture(name)
    Gem::Package.new(File.join("test", "gems", "#{name}.gem")).spec
  end
</Method>
<Method>
def gem_file(name = "test-0.0.0.gem")
    Rails.root.join("test", "gems", name.to_s).open("rb")
  end
</Method>
<Method>
def build_gemspec(gemspec)
    Gem::DefaultUserInteraction.use_ui(Gem::StreamUI.new(StringIO.new, StringIO.new)) do
      Gem::Package.build(gemspec, true)
    end
  end
</Method>
<Method>
def build_gem(name, version, summary = "Gemcutter", platform = "ruby", &)
    build_gemspec(new_gemspec(name, version, summary, platform, &))
  end
</Method>
<Method>
def new_gemspec(name, version, summary, platform, extra_args = {})
    ruby_version = extra_args[:ruby_version]
    rubygems_version = extra_args[:rubygems_version]
    Gem::Specification.new do |s|
      s.name = name
      s.platform = platform
      s.version = version.to_s
      s.authors = ["Someone"]
      s.date = Time.zone.now.strftime("%Y-%m-%d")
      s.description = summary.to_s
      s.email = "someone@example.com"
      s.files = []
      s.homepage = "http://example.com/#{name}"
      s.require_paths = ["lib"]
      s.summary = summary.to_s
      s.test_files = []
      s.licenses = []
      s.required_ruby_version = ruby_version
      s.required_rubygems_version = rubygems_version
      s.metadata = { "foo" => "bar" }
      yield s if block_given?
    end
  end
</Method>
File: test/integration/push_test.rb
Methods:
File: test/models/pusher_test.rb
Methods:
<Method>
def two_cert_chain(signing_key:, root_not_before: Time.current, cert_not_before: Time.current)
    root_key = OpenSSL::PKey::RSA.new(1024)
    root_subject = "/C=FI/O=Test/OU=Test/CN=Root"

    root_cert = OpenSSL::X509::Certificate.new
    root_cert.subject = root_cert.issuer = OpenSSL::X509::Name.parse(root_subject)
    root_cert.not_before = root_not_before
    root_cert.not_after = root_not_before + 1.year
    root_cert.public_key = root_key.public_key
    root_cert.serial = 0x0
    root_cert.version = 2
    root_cert.sign(root_key, OpenSSL::Digest.new("SHA256"))

    subject = "/C=FI/O=Test/OU=Test/CN=Test"

    cert = OpenSSL::X509::Certificate.new
    cert.issuer = OpenSSL::X509::Name.parse(root_subject)
    cert.subject = OpenSSL::X509::Name.parse(subject)
    cert.not_before = cert_not_before
    cert.not_after = cert_not_before + 1.year
    cert.public_key = signing_key.public_key
    cert.serial = 0x0
    cert.version = 2
    cert.sign(root_key, OpenSSL::Digest.new("SHA256"))

    [root_cert, cert]
  end
</Method>
