{
    "total_number_of_samples": 2,
    "timestamp": "08/10/2024 13:35:49",
    "errors": 0,
    "equal": 1,
    "accuracy_overall": 50.0,
    "accuracy_CWE": 50.0,
    "accuracy_severity": 50.0,
    "CWE_identical": 1,
    "CWE_gt_subset_of_pr": 0,
    "CWE_pr_subset_of_gt": 0,
    "CWE_empty_pr": 0,
    "CWE_non_overlapped": 1,
    "CWE_overlapped": 0,
    "equal_severities": 1,
    "invalid_inferences": 0,
    "cwe_evaluations": [
        {
            "llm_input": [
                {
                    "role": "system",
                    "content": "You are an expert in identifying Common Weakness Enumerations (CWEs) and assessing the severity of vulnerabilities based on both the buggy code(s) and bug description.\n\nInstructions:\n1. * Input: You will receive one or more sections of buggy files enclosed within <Code> and </Code>, and a description of the buggy code. If there are multiple buggy files, they will be related to the same bug. You may receive multiple file names and their contents provided as:\n   Description: description of the bug\n   File: file_name\n   Content: \n        <Code> content </Code>\n2. * Output: Generate a JSON object with the following structure:\n   {\n     \"CWE_IDS\": [], \n     \"severity\": null\n   }\n\nOutput Details:\n- CWE_IDS: If you identify any CWE IDs from the provided buggy code(s) or its description, list them here (e.g., [\"CWE-123\"]). If no CWEs are found, leave this as an empty array [].\n- severity: If the provided information indicates a security vulnerability (CVE), provide its severity level (e.g., \"high\") based on CVSS V3.1 . If there are no vulnerabilities, set this field to null.\n\nExample Outputs:\n1. If CWEs are found and severity is identified:\n   {\n     \"CWE_IDS\": [\"CWE-123\", \"CWE-456\"],\n     \"severity\": \"high\"\n   }\n\n2. If no CWEs or severity are identified:\n   {\n     \"CWE_IDS\": [],\n     \"severity\": null\n   }\n\nImportant: Your output must strictly follow the described JSON structure. Do not include any additional fields, descriptions, or text.\n\nCVSS v3.1 Guide:\n\nBase Metrics:\n1.\tAttack Vector (AV): How the vulnerability is exploited (Network (N), Adjacent Network (A), Local (L), Physical (P))\n2.\tAttack Complexity (AC): Difficulty of exploitation (Low (L), High (H))\n3.\tPrivileges Required (PR): Level of required privileges an attacker needs to exploit the vulnerability (None (N), Low (L), High (H))\n4.\tUser Interaction (UI): Need for user interaction (None (N), Required (R))\n5.\tScope (S): Impact on other components (Unchanged (U), Changed (C))\n6.\tConfidentiality (C), Integrity (I), Availability (A): Impact on security properties (None (N), Low (L), High (H))\n\nSeverity Levels and Example Combinations:\n1. None (0.0): This vulnerability is extremely difficult to exploit and has minimal impact. For example, \u201cAV:P/AC:H/PR:H/UI:R/S:U/C:N/I:N/A:N\u201d and \u201cAV:N/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:N\u201d\n2. Low (0.1 - 3.9): These vulnerabilities are somewhat difficult to exploit or have limited impact. For example, \u201cAV:L/AC:H/PR:L/UI:R/S:U/C:L/I:N/A:L\u201d and \u201cAV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N\u201d\n3. Medium (4.0 - 6.9): Involves vulnerabilities that are exploitable and could cause moderate damage. For example, \u201cAV:N/AC:H/PR:H/UI:R/S:C/C:L/I:L/A:N\u201d and \u201cAV:A/AC:L/PR:L/UI:N/S:U/C:L/I:H/A:L\u201d\n4. High (7.0 - 8.9): Represents vulnerabilities that are easier to exploit and have significant consequences. For example, \u201cAV:L/AC:H/PR:L/UI:N/S:C/C:H/I:L/A:L\u201d and \u201cAV:A/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:L\u201d\n5. Critical (9.0 - 10.0): These vulnerabilities are both easy to exploit and have a devastating impact. For example, \u201cAV:A/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H\u201d and \u201cAV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H\u201d\n\nNote: The severity level may change based on specific characteristics of the vulnerability. For example, if the attack vector is physical but the impact on availability is high, the severity might increase."
                },
                {
                    "role": "user",
                    "content": "Description: Address negative shift reported by https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=26229.\nAs I understand it, a corrupt EXR file has a declared length of a short Huffman code (pl.len) that exceeds the number of bits remaining to represent it (lc). This causes the lc to go negative, causing a negative left shift, which has undefined behavior.\nThis is the 'non-fast' path taken when there are less than 128 bits of data. testHuf has been updated to test with small as well as large data sizes to ensure both decoders are covered.\nSigned-off-by: Peter Hillman peterh@wetafx.co.nz\nFile: OpenEXR/IlmImfTest/testHuf.cpp\nContent: \n<Code>\n///////////////////////////////////////////////////////////////////////////\n//\n// Copyright (c) 2002-2012, Industrial Light & Magic, a division of Lucas\n// Digital Ltd. LLC\n// \n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n// *       Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// *       Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// *       Neither the name of Industrial Light & Magic nor the names of\n// its contributors may be used to endorse or promote products derived\n// from this software without specific prior written permission. \n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n///////////////////////////////////////////////////////////////////////////\n\n#ifdef NDEBUG\n#    undef NDEBUG\n#endif\n\n#include <ImfHuf.h>\n#include \"ImathRandom.h\"\n#include <ImfArray.h>\n#include <iostream>\n#include <exception>\n#include <limits.h>\n#include <math.h>\n#include <stdlib.h>\n#include <assert.h>\n\n\nusing namespace OPENEXR_IMF_NAMESPACE;\nusing namespace std;\n\n\nnamespace {\n\nvoid\nfill1 (unsigned short data[/*n*/], int n, float bias, IMATH_NAMESPACE::Rand48 & rand48)\n{\n    for (int i = 0; i < n; ++i)\n\tdata[i] = (unsigned short)\n\t\t  (pow (rand48.nextf(), double(bias)) * (USHRT_MAX + 1));\n}\n\n\nvoid\nfill2 (unsigned short data[/*n*/], int n, int m, IMATH_NAMESPACE::Rand48 & rand48)\n{\n    for (int i = 0; i < n; ++i)\n\tdata[i] = 0;\n\n    for (int i = 0; i < m; ++i)\n\tdata[rand48.nexti() % n] = (unsigned short) (rand48.nextf() * (USHRT_MAX + 1));\n}\n\n\nvoid\nfill3 (unsigned short data[/*n*/], int n, int m)\n{\n    for (int i = 0; i < n; ++i)\n\tdata[i] = m;\n}\n\n\nvoid\nfill4 (unsigned short data[/*n*/], int n)\n{\n    for (int i = 0; i < n; ++i)\n\tdata[i] = i & USHRT_MAX;\n}\n\n\nvoid\nfill5 (unsigned short data[/*n*/], int n)\n{\n    for (int i = 0; i < n; ++i)\n\tdata[i] = 0;\n\n    int j = 0, k = 0;\n\n    for (int i = 0; i < n; ++i)\n    {\n\tdata[i] = j;\n\tj = j + k;\n\tk = k + 1;\n\n\tif (j > USHRT_MAX)\n\t    break;\n    }\n}\n\n\nvoid\ncompressUncompress (const unsigned short raw[], int n)\n{\n    Array <char> compressed (3 * n + 4 * 65536);\n    Array <unsigned short> uncompressed (n);\n\n    cout << \"compressing \" << flush;\n\n    int nCompressed = hufCompress (raw, n, compressed);\n\n    cout << \"uncompressing \" << flush;\n\n    hufUncompress (compressed, nCompressed, uncompressed, n);\n\n    cout << \"comparing: \" << flush;\n\n    for (int i = 0; i < n; ++i)\n\tassert (uncompressed[i] == raw[i]);\n\n    cout << sizeof (raw[0]) * n << \" bytes, compressed \" <<\n\t    nCompressed  << \" bytes\" << endl;\n}\n\nvoid\ncompressUncompressSubset(const unsigned short raw[], int n)\n{\n    // Test various subsets of the data set\n\n    Array <char> compressed (3 * n + 4 * 65536);\n    Array <unsigned short> uncompressed (n);\n\n    int maxOffset = 16;\n    if (n <= maxOffset) {\n        maxOffset = n-1;\n    }\n\n    for (int offset=1; offset<maxOffset; ++offset) {\n\n        int maxLength = n - offset;\n        int minLength = maxLength - 16;\n        if (minLength < 1) minLength = 1;\n\n        for (int length=minLength; length<=maxLength; ++length) {\n            cout << \"compressing \" << flush;\n\n            int nCompressed = hufCompress (raw + offset, length, compressed + offset);\n\n            cout << \"uncompressing \" << flush;\n\n            hufUncompress (compressed + offset, nCompressed, uncompressed + offset, length);\n\n            for (int i = 0; i < length; ++i)\n                assert (uncompressed[offset+i] == raw[offset+i]);\n\n            cout << sizeof (raw[0]) * length << \" bytes, compressed \" << nCompressed  << \" bytes \";\n            cout << \"(+\" << offset << \",-\" << n-offset-length << \")\" << endl;\n        }\n    }\n}\n\n\n\n//\n//  Check the hash is 'dekHash'.\n//  This check is intended to test for regressions\n//  in the hufCompress() result or difference results across OSes.\n// \n// The platform agnostic DEK hash of the huf compressed data for\n// the set of numbers generated by fill4() and fill5().\n// This DEK hash is determined from an aprior initial run of this\n// test noting its value from the assert message compressVerify().\n// \n#define  HUF_COMPRESS_DEK_HASH_FOR_FILL4_USHRT_MAX_PLUS_ONE 2013380646U\n#define  HUF_COMPRESS_DEK_HASH_FOR_FILL4_N 213880353U\n#define  HUF_COMPRESS_DEK_HASH_FOR_FILL5_N 2492982090U\n\nvoid\ncompressVerify (const unsigned short raw[], \n                int n,\n                const unsigned int dekHash)\n{\n    Array <char> compressed (3 * n + 4 * 65536);\n\n    int nCompressed = hufCompress (raw, n, compressed);\n    \n    //\n    // This hash algorithm proposed by Donald E. Knuth in \n    // The Art Of Computer Programming Volume 3,\n    // under the topic of sorting and search chapter 6.4. \n    //\n    unsigned int compressedHash = nCompressed;\n    const unsigned char* cptr = reinterpret_cast<const unsigned char*>( (const char*) compressed);\n    for (int i = 0; i < nCompressed; ++i)\n    {\n        compressedHash = \n            ((compressedHash << 5) ^ (compressedHash >> 27)) ^ (*cptr++);\n    }\n\n    cout << \"verifying compressed checksum hash = \" \n        << compressedHash << std::endl;\n\n    if (compressedHash != dekHash)\n    {\n       cout << \"hash verification failed. Got \" << compressedHash << \" expected \" << dekHash << std::endl;\n       const unsigned char* cptr = reinterpret_cast<const unsigned char*>( (const char*) compressed);\n       for(int i = 0 ; i < nCompressed ; ++i )\n       {\n           cout << std::hex << (0xFF & (int) (*cptr++));\n           if ( (i & 0xF) ==0 )\n           {\n              cout << '\\n';\n           }\n           else\n           {\n              cout << ' ';\n           }\n       }\n       cout << \"\\n\";\n    }\n\n    assert (compressedHash == dekHash);\n}\n\n\n} // namespace\n\n\nvoid\ntestHuf (const std::string&)\n{\n    try\n    {\n\tcout << \"Testing Huffman encoder\" << endl;\n\n\tIMATH_NAMESPACE::Rand48 rand48 (0);\n\n\tconst int N = 1000000;\n\tArray <unsigned short> raw (N);\n\n\tfill1 (raw, N, 1, rand48);\t  // test various symbol distributions\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill1 (raw, N, 10, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill1 (raw, N, 100, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill1 (raw, N, 1000, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tfill2 (raw, N, 1, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill2 (raw, N, 10, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill2 (raw, N, 100, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill2 (raw, N, 1000, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tfill3 (raw, N, 0);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill3 (raw, N, 1);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill3 (raw, N, USHRT_MAX - 1);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill3 (raw, N, USHRT_MAX);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tfill4 (raw, USHRT_MAX + 1);\n        compressVerify(raw, USHRT_MAX + 1, HUF_COMPRESS_DEK_HASH_FOR_FILL4_USHRT_MAX_PLUS_ONE);\n\tcompressUncompress (raw, USHRT_MAX + 1);\n\tcompressUncompressSubset (raw, USHRT_MAX + 1);\n\tfill4 (raw, N);\n        compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL4_N);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tfill4 (raw, 0);\n\tcompressUncompress (raw, 0);\t// test small input data sets\n\tfill4 (raw, 1);\n\tcompressUncompress (raw, 1);\n\tfill4 (raw, 2);\n\tcompressUncompress (raw, 2);\n\tfill4 (raw, 3);\n\tcompressUncompress (raw, 3);\n\n\tfill5 (raw, N);\t\t\t// test run-length coding of code table\n        compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL5_N);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tcout << \"ok\\n\" << endl;\n    }\n    catch (const std::exception &e)\n    {\n\tcerr << \"ERROR -- caught exception: \" << e.what() << endl;\n\tassert (false);\n    }\n}\n</Code>"
                }
            ],
            "url": "https://github.com/AcademySoftwareFoundation/openexr/commit/51a92d67f53c08230734e74564c807043cbfe41e",
            "description": "A flaw was found in OpenEXR's hufDecode functionality. This flaw allows an attacker who can pass a crafted file to be processed by OpenEXR, to trigger an undefined right shift error. The highest threat from this vulnerability is to system availability.",
            "date": "2022-08-23",
            "github_description": "Address negative shift reported by https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=26229.\nAs I understand it, a corrupt EXR file has a declared length of a short Huffman code (pl.len) that exceeds the number of bits remaining to represent it (lc). This causes the lc to go negative, causing a negative left shift, which has undefined behavior.\nThis is the 'non-fast' path taken when there are less than 128 bits of data. testHuf has been updated to test with small as well as large data sizes to ensure both decoders are covered.\nSigned-off-by: Peter Hillman peterh@wetafx.co.nz",
            "llm_raw_output": "{\n\t\"CWE_IDS\": [\"CWE-190\"],\n\t\"severity\": \"high\"\n}",
            "llm_output": {
                "CWE_IDS": [
                    "CWE-190"
                ],
                "severity": "HIGH"
            },
            "ground_truth_CVE": "CVE-2021-20304",
            "ground_truth_CWEs": [
                "CWE-190"
            ],
            "ground_truth_severities": {
                "V3.1": "HIGH"
            },
            "ground_truth_CVSS_version": [
                "V3.1"
            ],
            "is_equal": true,
            "error_msg": null,
            "equal_severity": true,
            "cwe_evaluation": "IDENTICAL"
        },
        {
            "llm_input": [
                {
                    "role": "system",
                    "content": "You are an expert in identifying Common Weakness Enumerations (CWEs) and assessing the severity of vulnerabilities based on both the buggy code(s) and bug description.\n\nInstructions:\n1. * Input: You will receive one or more sections of buggy files enclosed within <Code> and </Code>, and a description of the buggy code. If there are multiple buggy files, they will be related to the same bug. You may receive multiple file names and their contents provided as:\n   Description: description of the bug\n   File: file_name\n   Content: \n        <Code> content </Code>\n2. * Output: Generate a JSON object with the following structure:\n   {\n     \"CWE_IDS\": [], \n     \"severity\": null\n   }\n\nOutput Details:\n- CWE_IDS: If you identify any CWE IDs from the provided buggy code(s) or its description, list them here (e.g., [\"CWE-123\"]). If no CWEs are found, leave this as an empty array [].\n- severity: If the provided information indicates a security vulnerability (CVE), provide its severity level (e.g., \"high\") based on CVSS V3.1 . If there are no vulnerabilities, set this field to null.\n\nExample Outputs:\n1. If CWEs are found and severity is identified:\n   {\n     \"CWE_IDS\": [\"CWE-123\", \"CWE-456\"],\n     \"severity\": \"high\"\n   }\n\n2. If no CWEs or severity are identified:\n   {\n     \"CWE_IDS\": [],\n     \"severity\": null\n   }\n\nImportant: Your output must strictly follow the described JSON structure. Do not include any additional fields, descriptions, or text.\n\nCVSS v3.1 Guide:\n\nBase Metrics:\n1.\tAttack Vector (AV): How the vulnerability is exploited (Network (N), Adjacent Network (A), Local (L), Physical (P))\n2.\tAttack Complexity (AC): Difficulty of exploitation (Low (L), High (H))\n3.\tPrivileges Required (PR): Level of required privileges an attacker needs to exploit the vulnerability (None (N), Low (L), High (H))\n4.\tUser Interaction (UI): Need for user interaction (None (N), Required (R))\n5.\tScope (S): Impact on other components (Unchanged (U), Changed (C))\n6.\tConfidentiality (C), Integrity (I), Availability (A): Impact on security properties (None (N), Low (L), High (H))\n\nSeverity Levels and Example Combinations:\n1. None (0.0): This vulnerability is extremely difficult to exploit and has minimal impact. For example, \u201cAV:P/AC:H/PR:H/UI:R/S:U/C:N/I:N/A:N\u201d and \u201cAV:N/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:N\u201d\n2. Low (0.1 - 3.9): These vulnerabilities are somewhat difficult to exploit or have limited impact. For example, \u201cAV:L/AC:H/PR:L/UI:R/S:U/C:L/I:N/A:L\u201d and \u201cAV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N\u201d\n3. Medium (4.0 - 6.9): Involves vulnerabilities that are exploitable and could cause moderate damage. For example, \u201cAV:N/AC:H/PR:H/UI:R/S:C/C:L/I:L/A:N\u201d and \u201cAV:A/AC:L/PR:L/UI:N/S:U/C:L/I:H/A:L\u201d\n4. High (7.0 - 8.9): Represents vulnerabilities that are easier to exploit and have significant consequences. For example, \u201cAV:L/AC:H/PR:L/UI:N/S:C/C:H/I:L/A:L\u201d and \u201cAV:A/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:L\u201d\n5. Critical (9.0 - 10.0): These vulnerabilities are both easy to exploit and have a devastating impact. For example, \u201cAV:A/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H\u201d and \u201cAV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H\u201d\n\nNote: The severity level may change based on specific characteristics of the vulnerability. For example, if the attack vector is physical but the impact on availability is high, the severity might increase."
                },
                {
                    "role": "user",
                    "content": "Description: B44 was allocating a _tmpBuffer of maxScanLineSize*numScanlines unsigned short values. maxScanLineSize is the number of bytes of uncompressed data on each scanline, not the number of pixel samples. _tmpBuffer was therefore assigning one 16 bit short for every byte of uncompressed data, so making the buffer twice the size it needs to be\npartially addresses out-of-memory issue https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=25913\nSigned-off-by: Peter Hillman peterh@wetafx.co.nz\nFile: OpenEXR/IlmImf/ImfB44Compressor.cpp\nContent: \n<Code>\n///////////////////////////////////////////////////////////////////////////\n//\n// Copyright (c) 2006, Industrial Light & Magic, a division of Lucas\n// Digital Ltd. LLC\n// \n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n// *       Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// *       Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// *       Neither the name of Industrial Light & Magic nor the names of\n// its contributors may be used to endorse or promote products derived\n// from this software without specific prior written permission. \n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n///////////////////////////////////////////////////////////////////////////\n\n\n//-----------------------------------------------------------------------------\n//\n//\tclass B44Compressor\n//\n//\tThis compressor is lossy for HALF channels; the compression rate\n//\tis fixed at 32/14 (approximately 2.28).  FLOAT and UINT channels\n//\tare not compressed; their data are preserved exactly.\n//\n//\tEach HALF channel is split into blocks of 4 by 4 pixels.  An\n//\tuncompressed block occupies 32 bytes, which are re-interpreted\n//\tas sixteen 16-bit unsigned integers, t[0] ... t[15].  Compression\n//\tshrinks the block to 14 bytes.  The compressed 14-byte block\n//\tcontains\n//\n//\t - t[0]\n//\n//\t - a 6-bit shift value\n//\n//\t - 15 densely packed 6-bit values, r[0] ... r[14], which are\n//         computed by subtracting adjacent pixel values and right-\n//\t   shifting the differences according to the stored shift value.\n//\n//\t   Differences between adjacent pixels are computed according\n//\t   to the following diagram:\n//\n//\t\t 0 -------->  1 -------->  2 -------->  3\n//               |     3            7           11\n//               |\n//               | 0\n//               |\n//               v \n//\t\t 4 -------->  5 -------->  6 -------->  7\n//               |     4            8           12\n//               |\n//               | 1\n//               |\n//               v\n//\t\t 8 -------->  9 --------> 10 --------> 11\n//               |     5            9           13\n//               |\n//               | 2\n//               |\n//               v\n//\t\t12 --------> 13 --------> 14 --------> 15\n//                     6           10           14\n//\n//\t    Here\n//\n//               5 ---------> 6\n//                     8\n//\n//\t    means that r[8] is the difference between t[5] and t[6].\n//\n//\t - optionally, a 4-by-4 pixel block where all pixels have the\n//\t   same value can be treated as a special case, where the\n//\t   compressed block contains only 3 instead of 14 bytes:\n//\t   t[0], followed by an \"impossible\" 6-bit shift value and\n//\t   two padding bits.\n//\n//\tThis compressor can handle positive and negative pixel values.\n//\tNaNs and infinities are replaced with zeroes before compression.\n//\n//-----------------------------------------------------------------------------\n\n#include \"ImfB44Compressor.h\"\n#include \"ImfHeader.h\"\n#include \"ImfChannelList.h\"\n#include \"ImfMisc.h\"\n#include \"ImfCheckedArithmetic.h\"\n#include <ImathFun.h>\n#include <ImathBox.h>\n#include <Iex.h>\n#include <ImfIO.h>\n#include <ImfXdr.h>\n#include <string.h>\n#include <assert.h>\n#include <algorithm>\n#include \"ImfNamespace.h\"\n\n\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_ENTER\n\n\nusing IMATH_NAMESPACE::divp;\nusing IMATH_NAMESPACE::modp;\nusing IMATH_NAMESPACE::Box2i;\nusing IMATH_NAMESPACE::V2i;\nusing std::min;\n\nnamespace {\n\n//\n// Lookup tables for\n//\ty = exp (x / 8)\n// and \n//\tx = 8 * log (y)\n//\n\n#include \"b44ExpLogTable.h\"\n\n\ninline void\nconvertFromLinear (unsigned short s[16])\n{\n    for (int i = 0; i < 16; ++i)\n\ts[i] = expTable[s[i]];\n}\n\n\ninline void\nconvertToLinear (unsigned short s[16])\n{\n    for (int i = 0; i < 16; ++i)\n\ts[i] = logTable[s[i]];\n}\n\n\ninline int\nshiftAndRound (int x, int shift)\n{\n    //\n    // Compute\n    //\n    //     y = x * pow (2, -shift),\n    //\n    // then round y to the nearest integer.\n    // In case of a tie, where y is exactly\n    // halfway between two integers, round\n    // to the even one.\n    //\n\n    x <<= 1;\n    int a = (1 << shift) - 1;\n    shift += 1;\n    int b = (x >> shift) & 1;\n    return (x + a + b) >> shift;\n}\n\n\nint\npack (const unsigned short s[16],\n      unsigned char b[14],\n      bool optFlatFields,\n      bool exactMax)\n{\n    //\n    // Pack a block of 4 by 4 16-bit pixels (32 bytes) into\n    // either 14 or 3 bytes.\n    //\n\n    //\n    // Integers s[0] ... s[15] represent floating-point numbers\n    // in what is essentially a sign-magnitude format.  Convert\n    // s[0] .. s[15] into a new set of integers, t[0] ... t[15],\n    // such that if t[i] is greater than t[j], the floating-point\n    // number that corresponds to s[i] is always greater than\n    // the floating-point number that corresponds to s[j].\n    //\n    // Also, replace any bit patterns that represent NaNs or\n    // infinities with bit patterns that represent floating-point\n    // zeroes.\n    //\n    //\tbit pattern\tfloating-point\t\tbit pattern\n    //\tin s[i]\t\tvalue\t\t\tin t[i]\n    //\n    //  0x7fff\t\tNAN\t\t\t0x8000\n    //  0x7ffe\t\tNAN\t\t\t0x8000\n    //\t  ...\t\t\t\t\t  ...\n    //  0x7c01\t\tNAN\t\t\t0x8000\n    //  0x7c00\t\t+infinity\t\t0x8000\n    //  0x7bff\t\t+HALF_MAX\t\t0xfbff\n    //  0x7bfe\t\t\t\t\t0xfbfe\n    //  0x7bfd\t\t\t\t\t0xfbfd\n    //\t  ...\t\t\t\t\t  ...\n    //  0x0002\t\t+2 * HALF_MIN\t\t0x8002\n    //  0x0001\t\t+HALF_MIN\t\t0x8001\n    //  0x0000\t\t+0.0\t\t\t0x8000\n    //  0x8000\t\t-0.0\t\t\t0x7fff\n    //  0x8001\t\t-HALF_MIN\t\t0x7ffe\n    //  0x8002\t\t-2 * HALF_MIN\t\t0x7ffd\n    //\t  ...\t\t\t\t\t  ...\n    //  0xfbfd\t\t\t\t\t0x0f02\n    //  0xfbfe\t\t\t\t\t0x0401\n    //  0xfbff\t\t-HALF_MAX\t\t0x0400\n    //  0xfc00\t\t-infinity\t\t0x8000\n    //  0xfc01\t\tNAN\t\t\t0x8000\n    //\t  ...\t\t\t\t\t  ...\n    //  0xfffe\t\tNAN\t\t\t0x8000\n    //  0xffff\t\tNAN\t\t\t0x8000\n    //\n\n    unsigned short t[16];\n\n    for (int i = 0; i < 16; ++i)\n    {\n\tif ((s[i] & 0x7c00) == 0x7c00)\n\t    t[i] = 0x8000;\n\telse if (s[i] & 0x8000)\n\t    t[i] = ~s[i];\n\telse\n\t    t[i] = s[i] | 0x8000;\n    }\n    \n    //\n    // Find the maximum, tMax, of t[0] ... t[15].\n    //\n\n    unsigned short tMax = 0;\n\n    for (int i = 0; i < 16; ++i)\n\tif (tMax < t[i])\n\t    tMax = t[i];\n\n    //\n    // Compute a set of running differences, r[0] ... r[14]:\n    // Find a shift value such that after rounding off the\n    // rightmost bits and shifting all differenes are between\n    // -32 and +31.  Then bias the differences so that they\n    // end up between 0 and 63.\n    //\n\n    int shift = -1;\n    int d[16];\n    int r[15];\n    int rMin;\n    int rMax;\n\n    const int bias = 0x20;\n\n    do\n    {\n        shift += 1;\n\n        //\n        // Compute absolute differences, d[0] ... d[15],\n        // between tMax and t[0] ... t[15].\n        //\n        // Shift and round the absolute differences.\n        //\n\n        for (int i = 0; i < 16; ++i)\n            d[i] = shiftAndRound (tMax - t[i], shift);\n\n        //\n        // Convert d[0] .. d[15] into running differences\n        //\n\n        r[ 0] = d[ 0] - d[ 4] + bias;\n        r[ 1] = d[ 4] - d[ 8] + bias;\n        r[ 2] = d[ 8] - d[12] + bias;\n\n        r[ 3] = d[ 0] - d[ 1] + bias;\n        r[ 4] = d[ 4] - d[ 5] + bias;\n        r[ 5] = d[ 8] - d[ 9] + bias;\n        r[ 6] = d[12] - d[13] + bias;\n\n        r[ 7] = d[ 1] - d[ 2] + bias;\n        r[ 8] = d[ 5] - d[ 6] + bias;\n        r[ 9] = d[ 9] - d[10] + bias;\n        r[10] = d[13] - d[14] + bias;\n\n        r[11] = d[ 2] - d[ 3] + bias;\n        r[12] = d[ 6] - d[ 7] + bias;\n        r[13] = d[10] - d[11] + bias;\n        r[14] = d[14] - d[15] + bias;\n\n        rMin = r[0];\n        rMax = r[0];\n\n        for (int i = 1; i < 15; ++i)\n        {\n            if (rMin > r[i])\n                rMin = r[i];\n\n            if (rMax < r[i])\n                rMax = r[i];\n        }\n    }\n    while (rMin < 0 || rMax > 0x3f);\n\n    if (rMin == bias && rMax == bias && optFlatFields)\n    {\n        //\n        // Special case - all pixels have the same value.\n        // We encode this in 3 instead of 14 bytes by\n        // storing the value 0xfc in the third output byte,\n        // which cannot occur in the 14-byte encoding.\n        //\n\n        b[0] = (t[0] >> 8);\n        b[1] = (unsigned char) t[0];\n        b[2] = 0xfc;\n\n        return 3;\n    }\n\n    if (exactMax)\n    {\n        //\n        // Adjust t[0] so that the pixel whose value is equal\n        // to tMax gets represented as accurately as possible.\n        //\n\n        t[0] = tMax - (d[0] << shift);\n    }\n\n    //\n    // Pack t[0], shift and r[0] ... r[14] into 14 bytes:\n    //\n\n    b[ 0] = (t[0] >> 8);\n    b[ 1] = (unsigned char) t[0];\n\n    b[ 2] = (unsigned char) ((shift << 2) | (r[ 0] >> 4));\n    b[ 3] = (unsigned char) ((r[ 0] << 4) | (r[ 1] >> 2));\n    b[ 4] = (unsigned char) ((r[ 1] << 6) |  r[ 2]      );\n\n    b[ 5] = (unsigned char) ((r[ 3] << 2) | (r[ 4] >> 4));\n    b[ 6] = (unsigned char) ((r[ 4] << 4) | (r[ 5] >> 2));\n    b[ 7] = (unsigned char) ((r[ 5] << 6) |  r[ 6]      );\n\n    b[ 8] = (unsigned char) ((r[ 7] << 2) | (r[ 8] >> 4));\n    b[ 9] = (unsigned char) ((r[ 8] << 4) | (r[ 9] >> 2));\n    b[10] = (unsigned char) ((r[ 9] << 6) |  r[10]      );\n\n    b[11] = (unsigned char) ((r[11] << 2) | (r[12] >> 4));\n    b[12] = (unsigned char) ((r[12] << 4) | (r[13] >> 2));\n    b[13] = (unsigned char) ((r[13] << 6) |  r[14]      );\n\n    return 14;\n}\n\n\ninline\nvoid\nunpack14 (const unsigned char b[14], unsigned short s[16])\n{\n    //\n    // Unpack a 14-byte block into 4 by 4 16-bit pixels.\n    //\n\n    #if defined (DEBUG)\n\tassert (b[2] != 0xfc);\n    #endif\n\n    s[ 0] = (b[0] << 8) | b[1];\n\n    unsigned short shift = (b[ 2] >> 2);\n    unsigned short bias = (0x20u << shift);\n\n    s[ 4] = s[ 0] + ((((b[ 2] << 4) | (b[ 3] >> 4)) & 0x3fu) << shift) - bias;\n    s[ 8] = s[ 4] + ((((b[ 3] << 2) | (b[ 4] >> 6)) & 0x3fu) << shift) - bias;\n    s[12] = s[ 8] +   ((b[ 4]                       & 0x3fu) << shift) - bias;\n    \n    s[ 1] = s[ 0] +   ((unsigned int) (b[ 5] >> 2)           << shift) - bias;\n    s[ 5] = s[ 4] + ((((b[ 5] << 4) | (b[ 6] >> 4)) & 0x3fu) << shift) - bias;\n    s[ 9] = s[ 8] + ((((b[ 6] << 2) | (b[ 7] >> 6)) & 0x3fu) << shift) - bias;\n    s[13] = s[12] +   ((b[ 7]                       & 0x3fu) << shift) - bias;\n    \n    s[ 2] = s[ 1] +   ((unsigned int)(b[ 8] >> 2)            << shift) - bias;\n    s[ 6] = s[ 5] + ((((b[ 8] << 4) | (b[ 9] >> 4)) & 0x3fu) << shift) - bias;\n    s[10] = s[ 9] + ((((b[ 9] << 2) | (b[10] >> 6)) & 0x3fu) << shift) - bias;\n    s[14] = s[13] +   ((b[10]                       & 0x3fu) << shift) - bias;\n    \n    s[ 3] = s[ 2] +   ((unsigned int)(b[11] >> 2)            << shift) - bias;\n    s[ 7] = s[ 6] + ((((b[11] << 4) | (b[12] >> 4)) & 0x3fu) << shift) - bias;\n    s[11] = s[10] + ((((b[12] << 2) | (b[13] >> 6)) & 0x3fu) << shift) - bias;\n    s[15] = s[14] +   ((b[13]                       & 0x3fu) << shift) - bias;\n\n    for (int i = 0; i < 16; ++i)\n    {\n\tif (s[i] & 0x8000)\n\t    s[i] &= 0x7fff;\n\telse\n\t    s[i] = ~s[i];\n    }\n}\n\n\ninline\nvoid\nunpack3 (const unsigned char b[3], unsigned short s[16])\n{\n    //\n    // Unpack a 3-byte block into 4 by 4 identical 16-bit pixels.\n    //\n\n    #if defined (DEBUG)\n\tassert (b[2] == 0xfc);\n    #endif\n\n    s[0] = (b[0] << 8) | b[1];\n\n    if (s[0] & 0x8000)\n\ts[0] &= 0x7fff;\n    else\n\ts[0] = ~s[0];\n\n    for (int i = 1; i < 16; ++i)\n\ts[i] = s[0];\n}\n\n\nvoid\nnotEnoughData ()\n{\n    throw IEX_NAMESPACE::InputExc (\"Error decompressing data \"\n\t\t\t \"(input data are shorter than expected).\");\n}\n\n\nvoid\ntooMuchData ()\n{\n    throw IEX_NAMESPACE::InputExc (\"Error decompressing data \"\n\t\t\t \"(input data are longer than expected).\");\n}\n\n} // namespace\n\n\nstruct B44Compressor::ChannelData\n{\n    unsigned short *\tstart;\n    unsigned short *\tend;\n    int\t\t\tnx;\n    int\t\t\tny;\n    int\t\t\tys;\n    PixelType\t\ttype;\n    bool\t\tpLinear;\n    int\t\t\tsize;\n};\n\n\nB44Compressor::B44Compressor\n    (const Header &hdr,\n     size_t maxScanLineSize,\n     size_t numScanLines,\n     bool optFlatFields)\n:\n    Compressor (hdr),\n    _maxScanLineSize (maxScanLineSize),\n    _optFlatFields (optFlatFields),\n    _format (XDR),\n    _numScanLines (numScanLines),\n    _tmpBuffer (0),\n    _outBuffer (0),\n    _numChans (0),\n    _channels (hdr.channels()),\n    _channelData (0)\n{\n    // TODO: Remove this when we can change the ABI\n    (void)_maxScanLineSize;\n    //\n    // Allocate buffers for compressed an uncompressed pixel data,\n    // allocate a set of ChannelData structs to help speed up the\n    // compress() and uncompress() functions, below, and determine\n    // if uncompressed pixel data should be in native or Xdr format.\n    //\n\n    _tmpBuffer = new unsigned short\n        [checkArraySize (uiMult (maxScanLineSize, numScanLines),\n                         sizeof (unsigned short))];\n\n    const ChannelList &channels = header().channels();\n    int numHalfChans = 0;\n\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c)\n    {\n\tassert (pixelTypeSize (c.channel().type) % pixelTypeSize (HALF) == 0);\n\t++_numChans;\n\n\tif (c.channel().type == HALF)\n\t    ++numHalfChans;\n    }\n\n    //\n    // Compressed data may be larger than the input data\n    //\n\n    size_t padding = 12 * numHalfChans * (numScanLines + 3) / 4;\n\n    _outBuffer = new char\n        [uiAdd (uiMult (maxScanLineSize, numScanLines), padding)];\n\n    _channelData = new ChannelData[_numChans];\n\n    int i = 0;\n\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c, ++i)\n    {\n\t_channelData[i].ys = c.channel().ySampling;\n\t_channelData[i].type = c.channel().type;\n\t_channelData[i].pLinear = c.channel().pLinear;\n\t_channelData[i].size =\n\t    pixelTypeSize (c.channel().type) / pixelTypeSize (HALF);\n    }\n\n    const Box2i &dataWindow = hdr.dataWindow();\n\n    _minX = dataWindow.min.x;\n    _maxX = dataWindow.max.x;\n    _maxY = dataWindow.max.y;\n\n    //\n    // We can support uncompressed data in the machine's native\n    // format only if all image channels are of type HALF.\n    //\n\n    assert (sizeof (unsigned short) == pixelTypeSize (HALF));\n\n    if (_numChans == numHalfChans)\n\t_format = NATIVE;\n}\n\n\nB44Compressor::~B44Compressor ()\n{\n    delete [] _tmpBuffer;\n    delete [] _outBuffer;\n    delete [] _channelData;\n}\n\n\nint\nB44Compressor::numScanLines () const\n{\n    return _numScanLines;\n}\n\n\nCompressor::Format\nB44Compressor::format () const\n{\n    return _format;\n}\n\n\nint\nB44Compressor::compress (const char *inPtr,\n\t\t\t int inSize,\n\t\t\t int minY,\n\t\t\t const char *&outPtr)\n{\n    return compress (inPtr,\n\t\t     inSize,\n\t\t     Box2i (V2i (_minX, minY),\n\t\t\t    V2i (_maxX, minY + numScanLines() - 1)),\n\t\t     outPtr);\n}\n\n\nint\nB44Compressor::compressTile (const char *inPtr,\n\t\t\t     int inSize,\n\t\t\t     IMATH_NAMESPACE::Box2i range,\n\t\t\t     const char *&outPtr)\n{\n    return compress (inPtr, inSize, range, outPtr);\n}\n\n\nint\nB44Compressor::uncompress (const char *inPtr,\n\t\t\t   int inSize,\n\t\t\t   int minY,\n\t\t\t   const char *&outPtr)\n{\n    return uncompress (inPtr,\n\t\t       inSize,\n\t\t       Box2i (V2i (_minX, minY),\n\t\t\t      V2i (_maxX, minY + numScanLines() - 1)),\n\t\t       outPtr);\n}\n\n\nint\nB44Compressor::uncompressTile (const char *inPtr,\n\t\t\t       int inSize,\n\t\t\t       IMATH_NAMESPACE::Box2i range,\n\t\t\t       const char *&outPtr)\n{\n    return uncompress (inPtr, inSize, range, outPtr);\n}\n\n\nint\nB44Compressor::compress (const char *inPtr,\n\t\t\t int inSize,\n\t\t\t IMATH_NAMESPACE::Box2i range,\n\t\t\t const char *&outPtr)\n{\n    //\n    // Compress a block of pixel data:  First copy the input pixels\n    // from the input buffer into _tmpBuffer, rearranging them such\n    // that blocks of 4x4 pixels of a single channel can be accessed\n    // conveniently.  Then compress each 4x4 block of HALF pixel data\n    // and append the result to the output buffer.  Copy UINT and\n    // FLOAT data to the output buffer without compressing them.\n    //\n\n    outPtr = _outBuffer;\n\n    if (inSize == 0)\n    {\n\t//\n\t// Special case - empty input buffer.\n\t//\n\n\treturn 0;\n    }\n\n    //\n    // For each channel, detemine how many pixels are stored\n    // in the input buffer, and where those pixels will be\n    // placed in _tmpBuffer.\n    //\n\n    int minX = range.min.x;\n    int maxX = min (range.max.x, _maxX);\n    int minY = range.min.y;\n    int maxY = min (range.max.y, _maxY);\n    \n    unsigned short *tmpBufferEnd = _tmpBuffer;\n    int i = 0;\n\n    for (ChannelList::ConstIterator c = _channels.begin();\n\t c != _channels.end();\n\t ++c, ++i)\n    {\n\tChannelData &cd = _channelData[i];\n\n\tcd.start = tmpBufferEnd;\n\tcd.end = cd.start;\n\n\tcd.nx = numSamples (c.channel().xSampling, minX, maxX);\n\tcd.ny = numSamples (c.channel().ySampling, minY, maxY);\n\n\ttmpBufferEnd += cd.nx * cd.ny * cd.size;\n    }\n\n    if (_format == XDR)\n    {\n\t//\n\t// The data in the input buffer are in the machine-independent\n\t// Xdr format.  Copy the HALF channels into _tmpBuffer and\n\t// convert them back into native format for compression.\n\t// Copy UINT and FLOAT channels verbatim into _tmpBuffer.\n\t//\n\n\tfor (int y = minY; y <= maxY; ++y)\n\t{\n\t    for (int i = 0; i < _numChans; ++i)\n\t    {\n\t\tChannelData &cd = _channelData[i];\n\n\t\tif (modp (y, cd.ys) != 0)\n\t\t    continue;\n\n\t\tif (cd.type == HALF)\n\t\t{\n\t\t    for (int x = cd.nx; x > 0; --x)\n\t\t    {\n\t\t\tXdr::read <CharPtrIO> (inPtr, *cd.end);\n\t\t\t++cd.end;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    int n = cd.nx * cd.size;\n\t\t    memcpy (cd.end, inPtr, n * sizeof (unsigned short));\n\t\t    inPtr += n * sizeof (unsigned short);\n\t\t    cd.end += n;\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\t//\n\t// The input buffer contains only HALF channels, and they\n\t// are in native, machine-dependent format.  Copy the pixels\n\t// into _tmpBuffer.\n\t//\n\n\tfor (int y = minY; y <= maxY; ++y)\n\t{\n\t    for (int i = 0; i < _numChans; ++i)\n\t    {\n\t\tChannelData &cd = _channelData[i];\n\n\t\t#if defined (DEBUG)\n\t\t    assert (cd.type == HALF);\n\t\t#endif\n\n\t\tif (modp (y, cd.ys) != 0)\n\t\t    continue;\n\n\t\tint n = cd.nx * cd.size;\n\t\tmemcpy (cd.end, inPtr, n * sizeof (unsigned short));\n\t\tinPtr  += n * sizeof (unsigned short);\n\t\tcd.end += n;\n\t    }\n\t}\n    }\n\n    //\n    // The pixels for each channel have been packed into a contiguous\n    // block in _tmpBuffer.  HALF channels are in native format; UINT\n    // and FLOAT channels are in Xdr format.\n    //\n\n    #if defined (DEBUG)\n\n\tfor (int i = 1; i < _numChans; ++i)\n\t    assert (_channelData[i-1].end == _channelData[i].start);\n\n\tassert (_channelData[_numChans-1].end == tmpBufferEnd);\n\n    #endif\n\n    //\n    // For each HALF channel, split the data in _tmpBuffer into 4x4\n    // pixel blocks.  Compress each block and append the compressed\n    // data to the output buffer.\n    //\n    // UINT and FLOAT channels are copied from _tmpBuffer into the\n    // output buffer without further processing.\n    //\n\n    char *outEnd = _outBuffer;\n\n    for (int i = 0; i < _numChans; ++i)\n    {\n\tChannelData &cd = _channelData[i];\n\t\n\tif (cd.type != HALF)\n\t{\n\t    //\n\t    // UINT or FLOAT channel.\n\t    //\n\n\t    int n = cd.nx * cd.ny * cd.size * sizeof (unsigned short);\n\t    memcpy (outEnd, cd.start, n);\n\t    outEnd += n;\n\n\t    continue;\n\t}\n\t\n\t//\n\t// HALF channel\n\t//\n\n\tfor (int y = 0; y < cd.ny; y += 4)\n\t{\n\t    //\n\t    // Copy the next 4x4 pixel block into array s.\n\t    // If the width, cd.nx, or the height, cd.ny, of\n\t    // the pixel data in _tmpBuffer is not divisible\n\t    // by 4, then pad the data by repeating the\n\t    // rightmost column and the bottom row.\n\t    // \n\n\t    unsigned short *row0 = cd.start + y * cd.nx;\n\t    unsigned short *row1 = row0 + cd.nx;\n\t    unsigned short *row2 = row1 + cd.nx;\n\t    unsigned short *row3 = row2 + cd.nx;\n\n\t    if (y + 3 >= cd.ny)\n\t    {\n\t\tif (y + 1 >= cd.ny)\n\t\t    row1 = row0;\n\n\t\tif (y + 2 >= cd.ny)\n\t\t    row2 = row1;\n\n\t\trow3 = row2;\n\t    }\n\n\t    for (int x = 0; x < cd.nx; x += 4)\n\t    {\n\t\tunsigned short s[16];\n\n\t\tif (x + 3 >= cd.nx)\n\t\t{\n\t\t    int n = cd.nx - x;\n\n\t\t    for (int i = 0; i < 4; ++i)\n\t\t    {\n\t\t\tint j = min (i, n - 1);\n\n\t\t\ts[i +  0] = row0[j];\n\t\t\ts[i +  4] = row1[j];\n\t\t\ts[i +  8] = row2[j];\n\t\t\ts[i + 12] = row3[j];\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    memcpy (&s[ 0], row0, 4 * sizeof (unsigned short));\n\t\t    memcpy (&s[ 4], row1, 4 * sizeof (unsigned short));\n\t\t    memcpy (&s[ 8], row2, 4 * sizeof (unsigned short));\n\t\t    memcpy (&s[12], row3, 4 * sizeof (unsigned short));\n\t\t}\n\n\t\trow0 += 4;\n\t\trow1 += 4;\n\t\trow2 += 4;\n\t\trow3 += 4;\n\n\t\t//\n\t\t// Compress the contents of array s and append the\n\t\t// results to the output buffer.\n\t\t//\n\n\t\tif (cd.pLinear)\n\t\t    convertFromLinear (s);\n\n\t\toutEnd += pack (s, (unsigned char *) outEnd,\n\t\t\t\t_optFlatFields, !cd.pLinear);\n\t    }\n\t}\n    }\n\n    return outEnd - _outBuffer;\n}\n\n\nint\nB44Compressor::uncompress (const char *inPtr,\n\t\t\t   int inSize,\n\t\t\t   IMATH_NAMESPACE::Box2i range,\n\t\t\t   const char *&outPtr)\n{\n    //\n    // This function is the reverse of the compress() function,\n    // above.  First all pixels are moved from the input buffer\n    // into _tmpBuffer.  UINT and FLOAT channels are copied\n    // verbatim; HALF channels are uncompressed in blocks of\n    // 4x4 pixels.  Then the pixels in _tmpBuffer are copied\n    // into the output buffer and rearranged such that the data\n    // for for each scan line form a contiguous block.\n    //\n\n    outPtr = _outBuffer;\n\n    if (inSize == 0)\n    {\n\treturn 0;\n    }\n\n    int minX = range.min.x;\n    int maxX = min (range.max.x, _maxX);\n    int minY = range.min.y;\n    int maxY = min (range.max.y, _maxY);\n    \n    unsigned short *tmpBufferEnd = _tmpBuffer;\n    int i = 0;\n\n    for (ChannelList::ConstIterator c = _channels.begin();\n\t c != _channels.end();\n\t ++c, ++i)\n    {\n\tChannelData &cd = _channelData[i];\n\n\tcd.start = tmpBufferEnd;\n\tcd.end = cd.start;\n\n\tcd.nx = numSamples (c.channel().xSampling, minX, maxX);\n\tcd.ny = numSamples (c.channel().ySampling, minY, maxY);\n\n\ttmpBufferEnd += cd.nx * cd.ny * cd.size;\n    }\n\n    for (int i = 0; i < _numChans; ++i)\n    {\n\tChannelData &cd = _channelData[i];\n\n\tif (cd.type != HALF)\n\t{\n\t    //\n\t    // UINT or FLOAT channel.\n\t    //\n\n\t    int n = cd.nx * cd.ny * cd.size * sizeof (unsigned short);\n\n\t    if (inSize < n)\n\t\tnotEnoughData();\n\n\t    memcpy (cd.start, inPtr, n);\n\t    inPtr += n;\n\t    inSize -= n;\n\n\t    continue;\n\t}\n\n\t//\n\t// HALF channel\n\t//\n\n\tfor (int y = 0; y < cd.ny; y += 4)\n\t{\n\t    unsigned short *row0 = cd.start + y * cd.nx;\n\t    unsigned short *row1 = row0 + cd.nx;\n\t    unsigned short *row2 = row1 + cd.nx;\n\t    unsigned short *row3 = row2 + cd.nx;\n\n\t    for (int x = 0; x < cd.nx; x += 4)\n\t    {\n\t\tunsigned short s[16]; \n\n\t\tif (inSize < 3)\n\t\t    notEnoughData();\n\n                //\n                // If shift exponent is 63, call unpack14 (ignoring unused bits)\n                //\n\t\tif (((const unsigned char *)inPtr)[2] >= (13<<2) )\n\t\t{\n\t\t    unpack3 ((const unsigned char *)inPtr, s);\n\t\t    inPtr += 3;\n\t\t    inSize -= 3;\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (inSize < 14)\n\t\t\tnotEnoughData();\n\n\t\t    unpack14 ((const unsigned char *)inPtr, s);\n\t\t    inPtr += 14;\n\t\t    inSize -= 14;\n\t\t}\n\n\t\tif (cd.pLinear)\n\t\t    convertToLinear (s);\n\n\t\tint n = (x + 3 < cd.nx)?\n\t\t\t    4 * sizeof (unsigned short) :\n\t\t\t    (cd.nx - x) * sizeof (unsigned short);\n\n\t\tif (y + 3 < cd.ny)\n\t\t{\n\t\t    memcpy (row0, &s[ 0], n);\n\t\t    memcpy (row1, &s[ 4], n);\n\t\t    memcpy (row2, &s[ 8], n);\n\t\t    memcpy (row3, &s[12], n);\n\t\t}\n\t\telse\n\t\t{\n\t\t    memcpy (row0, &s[ 0], n);\n\n\t\t    if (y + 1 < cd.ny)\n\t\t\tmemcpy (row1, &s[ 4], n);\n\n\t\t    if (y + 2 < cd.ny)\n\t\t\tmemcpy (row2, &s[ 8], n);\n\t\t}\n\n\t\trow0 += 4;\n\t\trow1 += 4;\n\t\trow2 += 4;\n\t\trow3 += 4;\n\t    }\n\t}\n    }\n\n    char *outEnd = _outBuffer;\n\n    if (_format == XDR)\n    {\n\tfor (int y = minY; y <= maxY; ++y)\n\t{\n\t    for (int i = 0; i < _numChans; ++i)\n\t    {\n\t\tChannelData &cd = _channelData[i];\n\n\t\tif (modp (y, cd.ys) != 0)\n\t\t    continue;\n\n\t\tif (cd.type == HALF)\n\t\t{\n\t\t    for (int x = cd.nx; x > 0; --x)\n\t\t    {\n\t\t\tXdr::write <CharPtrIO> (outEnd, *cd.end);\n\t\t\t++cd.end;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    int n = cd.nx * cd.size;\n\t\t    memcpy (outEnd, cd.end, n * sizeof (unsigned short));\n\t\t    outEnd += n * sizeof (unsigned short);\n\t\t    cd.end += n;\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\tfor (int y = minY; y <= maxY; ++y)\n\t{\n\t    for (int i = 0; i < _numChans; ++i)\n\t    {\n\t\tChannelData &cd = _channelData[i];\n\n\t\t#if defined (DEBUG)\n\t\t    assert (cd.type == HALF);\n\t\t#endif\n\n\t\tif (modp (y, cd.ys) != 0)\n\t\t    continue;\n\n\t\tint n = cd.nx * cd.size;\n\t\tmemcpy (outEnd, cd.end, n * sizeof (unsigned short));\n\t\toutEnd += n * sizeof (unsigned short);\n\t\tcd.end += n;\n\t    }\n\t}\n    }\n\n    #if defined (DEBUG)\n\n\tfor (int i = 1; i < _numChans; ++i)\n\t    assert (_channelData[i-1].end == _channelData[i].start);\n\n\tassert (_channelData[_numChans-1].end == tmpBufferEnd);\n\n    #endif\n\n    if (inSize > 0)\n\ttooMuchData();\n\n    outPtr = _outBuffer;\n    return outEnd - _outBuffer;\n}\n\n\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_EXIT\n</Code>"
                }
            ],
            "url": "https://github.com/AcademySoftwareFoundation/openexr/commit/85fd638ae0d5fa132434f4cbf32590261c1dba97",
            "description": "A flaw was found in OpenEXR's B44Compressor. This flaw allows an attacker who can submit a crafted file to be processed by OpenEXR, to exhaust all memory accessible to the application. The highest threat from this vulnerability is to system availability.",
            "date": "2022-08-23",
            "github_description": "B44 was allocating a _tmpBuffer of maxScanLineSize*numScanlines unsigned short values. maxScanLineSize is the number of bytes of uncompressed data on each scanline, not the number of pixel samples. _tmpBuffer was therefore assigning one 16 bit short for every byte of uncompressed data, so making the buffer twice the size it needs to be\npartially addresses out-of-memory issue https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=25913\nSigned-off-by: Peter Hillman peterh@wetafx.co.nz",
            "llm_raw_output": "{\n  \"CWE_IDS\": [\n    \"CWE-126\",\n    \"CWE-682\"\n  ],\n  \"severity\": null\n}",
            "llm_output": {
                "CWE_IDS": [
                    "CWE-682",
                    "CWE-126"
                ],
                "severity": null
            },
            "ground_truth_CVE": "CVE-2021-20298",
            "ground_truth_CWEs": [
                "CWE-787"
            ],
            "ground_truth_severities": {
                "V3.1": "HIGH"
            },
            "ground_truth_CVSS_version": [
                "V3.1"
            ],
            "is_equal": false,
            "error_msg": null,
            "equal_severity": false,
            "cwe_evaluation": "NOT_OVERLAPPED"
        }
    ]
}