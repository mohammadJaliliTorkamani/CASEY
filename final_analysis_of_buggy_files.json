{
    "total_number_of_samples": 2,
    "date": "07/10/2024 10:38:47",
    "equal": 0,
    "accuracy_overall": 0.0,
    "accuracy_CWE": 0.0,
    "accuracy_severity": 0.0,
    "CWE_identical": 0,
    "CWE_gt_subset_of_pr": 0,
    "CWE_pr_subset_of_gt": 0,
    "CWE_empty_pr": 0,
    "CWE_empty_gt": 0,
    "CWE_non_overlapped": 2,
    "CWE_overlapped": 0,
    "equal_severities": 0,
    "invalid_inferences": 0,
    "cwe_evaluations": [
        {
            "llm_input": [
                {
                    "role": "system",
                    "content": "You are an expert in identifying Common Weakness Enumerations (CWEs) and assessing the severity of vulnerabilities in software code.\n\nInstructions:\n1. * Input: You will receive one or more files, each has a file name, and file content enclosed  within <Code> and </Code>. If there are multiple buggy codes, they will be related to the same bug. The provided input structure is as below:\n   File: file_name\n   Content: <Code> content </Code>\n2. * Output: Generate a JSON object with the following structure:\n   {\n     \"CWE_IDS\": [], \n     \"severity\": null\n   }\n\nOutput Details:\n- CWE_IDS: If you identify any CWE IDs in the provided buggy code(s), list them here (e.g., [\"CWE-123\"]). If no CWEs are found, leave this as an empty array [].\n- severity: If the buggy code(s) has a security vulnerability (CVE), provide its severity level (e.g., \"high\") based on CVSS V3.1 . If there are no vulnerabilities, set this field to null.\n\nExample Outputs:\n1. If CWEs are found and severity is identified:\n   {\n     \"CWE_IDS\": [\"CWE-123\", \"CWE-456\"],\n     \"severity\": \"high\"\n   }\n\n2. If no CWEs or severity are identified:\n   {\n     \"CWE_IDS\": [],\n     \"severity\": null\n   }\n\nImportant: Your output must strictly follow the described JSON structure. Do not include any additional fields, descriptions, or text.\n\nCVSS v3.1 Guide:\n\nBase Metrics:\n1.\tAttack Vector (AV): How the vulnerability is exploited (Network (N), Adjacent Network (A), Local (L), Physical (P))\n2.\tAttack Complexity (AC): Difficulty of exploitation (Low (L), High (H))\n3.\tPrivileges Required (PR): Level of required privileges an attacker needs to exploit the vulnerability (None (N), Low (L), High (H))\n4.\tUser Interaction (UI): Need for user interaction (None (N), Required (R))\n5.\tScope (S): Impact on other components (Unchanged (U), Changed (C))\n6.\tConfidentiality (C), Integrity (I), Availability (A): Impact on security properties (None (N), Low (L), High (H))\n\nSeverity Levels and Example Combinations:\n1. None (0.0): This vulnerability is extremely difficult to exploit and has minimal impact. For example, \u201cAV:P/AC:H/PR:H/UI:R/S:U/C:N/I:N/A:N\u201d and \u201cAV:N/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:N\u201d\n2. Low (0.1 - 3.9): These vulnerabilities are somewhat difficult to exploit or have limited impact. For example, \u201cAV:L/AC:H/PR:L/UI:R/S:U/C:L/I:N/A:L\u201d and \u201cAV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N\u201d\n3. Medium (4.0 - 6.9): Involves vulnerabilities that are exploitable and could cause moderate damage. For example, \u201cAV:N/AC:H/PR:H/UI:R/S:C/C:L/I:L/A:N\u201d and \u201cAV:A/AC:L/PR:L/UI:N/S:U/C:L/I:H/A:L\u201d\n4. High (7.0 - 8.9): Represents vulnerabilities that are easier to exploit and have significant consequences. For example, \u201cAV:L/AC:H/PR:L/UI:N/S:C/C:H/I:L/A:L\u201d and \u201cAV:A/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:L\u201d\n5. Critical (9.0 - 10.0): These vulnerabilities are both easy to exploit and have a devastating impact. For example, \u201cAV:A/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H\u201d and \u201cAV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H\u201d\n\nNote: The severity level may change based on specific characteristics of the vulnerability. For example, if the attack vector is physical but the impact on availability is high, the severity might increase.\n                              \n"
                },
                {
                    "role": "user",
                    "content": "File: app/models/pusher.rb\nContent: \n<Code>\nrequire \"digest/sha2\"\n\nclass Pusher\n  include TraceTagger\n  include SemanticLogger::Loggable\n\n  attr_reader :user, :spec, :message, :code, :rubygem, :body, :version, :version_id, :size\n\n  def initialize(user, body, remote_ip = \"\", scoped_rubygem = nil)\n    @user = user\n    @body = StringIO.new(body.read)\n    @size = @body.size\n    @remote_ip = remote_ip\n    @scoped_rubygem = scoped_rubygem\n  end\n\n  def process\n    trace(\"gemcutter.pusher.process\", tags: { \"gemcutter.user.id\" => user.id }) do\n      pull_spec && find && authorize && verify_gem_scope && verify_mfa_requirement && validate && save\n    end\n  end\n\n  def authorize\n    rubygem.pushable? || rubygem.owned_by?(user) || notify_unauthorized\n  end\n\n  def verify_gem_scope\n    return true unless @scoped_rubygem && rubygem != @scoped_rubygem\n\n    notify(\"This API key cannot perform the specified action on this gem.\", 403)\n  end\n\n  def verify_mfa_requirement\n    user.mfa_enabled? || !(version_mfa_required? || rubygem.metadata_mfa_required?) ||\n      notify(\"Rubygem requires owners to enable MFA. You must enable MFA before pushing new version.\", 403)\n  end\n\n  def validate\n    signature_missing = \"There was a problem saving your gem: \\nYou have added cert_chain in gemspec but signature was empty\"\n\n    return notify(signature_missing, 403) unless validate_signature_exists?\n    (rubygem.valid? && version.valid?) || notify(\"There was a problem saving your gem: #{rubygem.all_errors(version)}\", 403)\n  end\n\n  def save\n    # Restructured so that if we fail to write the gem (ie, s3 is down)\n    # can clean things up well.\n    return notify(\"There was a problem saving your gem: #{rubygem.all_errors(version)}\", 403) unless update\n    trace(\"gemcutter.pusher.write_gem\") do\n      write_gem @body, @spec\n    end\n  rescue ArgumentError => e\n    @version.destroy\n    Rails.error.report(e, handled: true)\n    notify(\"There was a problem saving your gem. #{e}\", 400)\n  rescue StandardError => e\n    @version.destroy\n    Rails.error.report(e, handled: true)\n    notify(\"There was a problem saving your gem. Please try again.\", 500)\n  else\n    after_write\n    notify(\"Successfully registered gem: #{version.to_title}\", 200)\n    true\n  end\n\n  def pull_spec\n    package = Gem::Package.new(body, gem_security_policy)\n    @spec = package.spec\n    @files = package.files\n  rescue StandardError => e\n    notify <<~MSG, 422\n      RubyGems.org cannot process this gem.\n      Please try rebuilding it and installing it locally to make sure it's valid.\n      Error:\n      #{e.message}\n    MSG\n  end\n\n  def find\n    name = spec.name.to_s\n    set_tag \"gemcutter.rubygem.name\", name\n\n    @rubygem = Rubygem.name_is(name).first || Rubygem.new(name: name)\n\n    unless @rubygem.new_record?\n      if (version = @rubygem.find_version_from_spec spec)\n        republish_notification(version)\n        return false\n      end\n\n      if @rubygem.name != name && @rubygem.indexed_versions?\n        return notify(\"Unable to change case of gem name with indexed versions\\n\" \\\n                      \"Please delete all versions first with `gem yank`.\", 409)\n      end\n    end\n\n    # Update the name to reflect a valid case change\n    @rubygem.name = name\n\n    sha256 = Digest::SHA2.base64digest(body.string)\n\n    @version = @rubygem.versions.new number: spec.version.to_s,\n                                     platform: spec.original_platform.to_s,\n                                     size: size,\n                                     sha256: sha256,\n                                     pusher: user,\n                                     cert_chain: spec.cert_chain\n\n    set_tags \"gemcutter.rubygem.version\" => @version.number, \"gemcutter.rubygem.platform\" => @version.platform\n    log_pushing\n\n    true\n  end\n\n  # Overridden so we don't get megabytes of the raw data printing out\n  def inspect\n    attrs = %i[@rubygem @user @message @code].map do |attr|\n      \"#{attr}=#{instance_variable_get(attr).inspect}\"\n    end\n    \"<Pusher #{attrs.join(' ')}>\"\n  end\n\n  private\n\n  def after_write\n    @version_id = version.id\n    version.rubygem.push_notifiable_owners.each do |notified_user|\n      Mailer.gem_pushed(user.id, @version_id, notified_user.id).deliver_later\n    end\n    Indexer.perform_later\n    UploadVersionsFileJob.perform_later\n    UploadInfoFileJob.perform_later(rubygem_name: rubygem.name)\n    ReindexRubygemJob.perform_later(rubygem:)\n    GemCachePurger.call(rubygem.name)\n    StoreVersionContentsJob.perform_later(version:) if ld_variation(key: \"gemcutter.pusher.store_version_contents\", default: false)\n    RackAttackReset.gem_push_backoff(@remote_ip, @user.display_id) if @remote_ip.present?\n    StatsD.increment \"push.success\"\n  end\n\n  def ld_variation(key:, default:)\n    Rails.configuration.launch_darkly_client.variation(\n      key, user.ld_context, default\n    )\n  end\n\n  def notify(message, code)\n    @message = message\n    @code    = code\n    false\n  end\n\n  def update\n    rubygem.disown if rubygem.versions.indexed.count.zero?\n    rubygem.update_attributes_from_gem_specification!(version, spec)\n    rubygem.create_ownership(user)\n    set_info_checksum\n\n    true\n  rescue ActiveRecord::RecordInvalid, ActiveRecord::Rollback, ActiveRecord::RecordNotUnique\n    false\n  end\n\n  def set_info_checksum\n    # TODO: may as well just upload this straight to S3...\n    checksum = GemInfo.new(rubygem.name).info_checksum\n    version.update_attribute :info_checksum, checksum\n  end\n\n  def republish_notification(version)\n    if version.indexed?\n      notify(\"Repushing of gem versions is not allowed.\\n\" \\\n             \"Please bump the version number and push a new different release.\\n\" \\\n             \"See also `gem yank` if you want to unpublish the bad release.\", 409)\n    else\n      different_owner = \"pushed by a previous owner of this gem \" unless version.rubygem.owners.include?(@user)\n      notify(\"A yanked version #{different_owner}already exists (#{version.full_name}).\\n\" \\\n             \"Repushing of gem versions is not allowed. Please use a new version and retry\", 409)\n    end\n  end\n\n  def notify_unauthorized\n    if rubygem.unconfirmed_ownership?(user)\n      notify(\"You do not have permission to push to this gem. \" \\\n             \"Please confirm the ownership by clicking on the confirmation link sent your email #{user.email}\", 403)\n    else\n      notify(\"You do not have permission to push to this gem. Ask an owner to add you with: gem owner #{rubygem.name} --add #{user.email}\", 403)\n    end\n  end\n\n  def gem_security_policy\n    @gem_security_policy ||= begin\n      # Verify that the gem signatures match the certificate chain (if present)\n      policy = PushPolicy.dup\n      # Silence warnings from the verification\n      stream = StringIO.new\n      policy.ui = Gem::StreamUI.new(stream, stream, stream, false)\n      policy\n    end\n  end\n\n  def validate_signature_exists?\n    return true if @spec.cert_chain.empty?\n\n    signatures = @files.select { |file| file[/\\.sig$/] }\n\n    expected_signatures = %w[metadata.gz.sig data.tar.gz.sig checksums.yaml.gz.sig]\n    expected_signatures.difference(signatures).empty?\n  end\n\n  def version_mfa_required?\n    ActiveRecord::Type::Boolean.new.cast(spec.metadata[\"rubygems_mfa_required\"])\n  end\n\n  def write_gem(body, spec)\n    original_name = spec.original_name\n\n    gem_path = \"gems/#{original_name}.gem\"\n    gem_contents = body.string\n\n    spec.abbreviate\n    spec.sanitize\n    spec_path = \"quick/Marshal.4.8/#{original_name}.gemspec.rz\"\n    spec_contents = Gem.deflate(Marshal.dump(spec))\n\n    spec_contents_checksum = Digest::SHA2.base64digest(spec_contents)\n\n    # do all processing _before_ we upload anything to S3, so we lower the chances of orphaned files\n    RubygemFs.instance.store(gem_path, gem_contents, checksum_sha256: version.sha256)\n    RubygemFs.instance.store(spec_path, spec_contents, checksum_sha256: spec_contents_checksum)\n\n    Fastly.purge(path: gem_path)\n    Fastly.purge(path: spec_path)\n  end\n\n  def log_pushing\n    logger.info do\n      # this is needed because the version can be invalid!\n      version =\n        begin\n          @version.as_json\n        rescue StandardError\n          {\n            number: @version.number,\n            platform: @version.platform\n          }\n        end\n\n      { message: \"Pushing gem\", version:, rubygem: @version.rubygem.name, pusher: user.as_json }\n    end\n  end\nend\n</Code>\n\nFile: app/models/specification_policy.rb\nContent: \n<Code>\n\n</Code>\n\nFile: app/models/version.rb\nContent: \n<Code>\nrequire \"digest/sha2\"\n\nclass Version < ApplicationRecord\n  RUBYGEMS_IMPORT_DATE = Date.parse(\"2009-07-25\")\n\n  belongs_to :rubygem, touch: true\n  has_many :dependencies, -> { order(\"rubygems.name ASC\").includes(:rubygem) }, dependent: :destroy, inverse_of: \"version\"\n  has_one :gem_download, inverse_of: :version, dependent: :destroy\n  belongs_to :pusher, class_name: \"User\", inverse_of: false, optional: true\n\n  before_validation :set_canonical_number, if: :number_changed?\n  before_validation :full_nameify!\n  before_save :update_prerelease, if: :number_changed?\n  # TODO: Remove this once we move to GemDownload only\n  after_create :create_gem_download\n  after_save :reorder_versions, if: -> { saved_change_to_indexed? || saved_change_to_id? }\n  after_save :refresh_rubygem_indexed, if: -> { saved_change_to_indexed? || saved_change_to_id? }\n\n  serialize :licenses\n  serialize :requirements\n  serialize :cert_chain, CertificateChainSerializer\n\n  validates :number, length: { maximum: Gemcutter::MAX_FIELD_LENGTH }, format: { with: /\\A#{Gem::Version::VERSION_PATTERN}\\z/o }\n  validates :platform, length: { maximum: Gemcutter::MAX_FIELD_LENGTH }, format: { with: Rubygem::NAME_PATTERN }\n  validates :full_name, presence: true, uniqueness: { case_sensitive: false }\n  validates :rubygem, presence: true\n  validates :required_rubygems_version, :licenses, length: { maximum: Gemcutter::MAX_FIELD_LENGTH }, allow_blank: true\n  validates :description, :summary, :authors, :requirements, :cert_chain,\n    length: { minimum: 0, maximum: Gemcutter::MAX_TEXT_FIELD_LENGTH },\n    allow_blank: true\n\n  validate :unique_canonical_number, on: :create\n  validate :platform_and_number_are_unique, on: :create\n  validate :authors_format, on: :create\n  validate :metadata_links_format\n  validate :metadata_attribute_length\n\n  class AuthorType < ActiveModel::Type::String\n    def cast_value(value)\n      if value.is_a?(Array)\n        value.join(\", \")\n      else\n        super\n      end\n    end\n  end\n  attribute :authors, AuthorType.new\n\n  def create_gem_download\n    GemDownload.create!(count: 0, rubygem_id: rubygem_id, version_id: id)\n  end\n\n  def self.reverse_dependencies(name)\n    joins(dependencies: :rubygem)\n      .indexed\n      .where(rubygems_dependencies: { name: name })\n  end\n\n  def self.reverse_runtime_dependencies(name)\n    reverse_dependencies(name)\n      .merge(Dependency.runtime)\n  end\n\n  def self.reverse_development_dependencies(name)\n    reverse_dependencies(name)\n      .merge(Dependency.development)\n  end\n\n  def self.owned_by(user)\n    where(rubygem_id: user.rubygem_ids)\n  end\n\n  def self.subscribed_to_by(user)\n    where(rubygem_id: user.subscribed_gem_ids)\n      .by_created_at\n  end\n\n  def self.latest\n    where(latest: true)\n  end\n\n  def self.prerelease\n    where(prerelease: true)\n  end\n\n  def self.release\n    where(prerelease: false)\n  end\n\n  def self.indexed\n    where(indexed: true)\n  end\n\n  def self.yanked\n    where(indexed: false)\n  end\n\n  def self.by_position\n    order(:position)\n  end\n\n  def self.by_created_at\n    order(created_at: :desc)\n  end\n\n  def self.rows_for_index\n    joins(:rubygem)\n      .indexed\n      .release\n      .order(\"rubygems.name asc, position desc\")\n      .pluck(\"rubygems.name\", :number, :platform)\n  end\n\n  def self.rows_for_latest_index\n    joins(:rubygem)\n      .indexed\n      .latest\n      .order(\"rubygems.name asc, position desc\")\n      .pluck(\"rubygems.name\", :number, :platform)\n  end\n\n  def self.rows_for_prerelease_index\n    joins(:rubygem)\n      .indexed\n      .prerelease\n      .order(\"rubygems.name asc, position desc\")\n      .pluck(\"rubygems.name\", :number, :platform)\n  end\n\n  def self.most_recent\n    latest.find_by(platform: \"ruby\") || latest.order(number: :desc).first || last\n  end\n\n  # This method returns the new versions for brand new rubygems\n  def self.new_pushed_versions(limit = 5)\n    subquery = <<~SQL.squish\n      versions.rubygem_id IN (SELECT versions.rubygem_id FROM versions\n        GROUP BY versions.rubygem_id HAVING COUNT(versions.rubygem_id) = 1\n        ORDER BY versions.rubygem_id DESC LIMIT :limit)\n    SQL\n\n    where(subquery, limit: limit).by_created_at\n  end\n\n  def self.just_updated(limit = 5)\n    six_months_ago_ts = 6.months.ago\n    subquery = <<~SQL.squish\n      versions.rubygem_id IN (SELECT versions.rubygem_id\n                                FROM versions\n                            WHERE versions.indexed = 'true' AND\n                                  versions.created_at > '#{six_months_ago_ts}'\n                            GROUP BY versions.rubygem_id\n                              HAVING COUNT(versions.id) > 1\n                              ORDER BY MAX(created_at) DESC LIMIT :limit)\n    SQL\n\n    where(subquery, limit: limit)\n      .joins(:rubygem)\n      .indexed\n      .by_created_at\n      .limit(limit)\n  end\n\n  def self.published(limit)\n    indexed.by_created_at.limit(limit)\n  end\n\n  def self.rubygem_name_for(full_name)\n    find_by(full_name: full_name)&.rubygem&.name\n  end\n\n  # id is added to ORDER to return stable results for gems pushed at the same time\n  def self.created_between(start_time, end_time)\n    where(created_at: start_time..end_time).order(:created_at, :id)\n  end\n\n  def platformed?\n    platform != \"ruby\"\n  end\n\n  delegate :reorder_versions, to: :rubygem\n\n  def authored_at\n    return built_at if rely_on_built_at?\n\n    created_at\n  end\n\n  def rely_on_built_at?\n    return false if created_at.to_date != RUBYGEMS_IMPORT_DATE\n\n    built_at && built_at <= RUBYGEMS_IMPORT_DATE\n  end\n\n  def refresh_rubygem_indexed\n    rubygem.refresh_indexed!\n  end\n\n  def previous\n    rubygem.versions.find_by(position: position + 1)\n  end\n\n  def next\n    rubygem.versions.find_by(position: position - 1)\n  end\n\n  def yanked?\n    !indexed\n  end\n\n  def cert_chain_valid_not_before\n    cert_chain.map(&:not_before).max\n  end\n\n  def cert_chain_valid_not_after\n    cert_chain.map(&:not_after).min\n  end\n\n  def signature_expired?\n    return false unless (expiration_time = cert_chain_valid_not_after)\n    expiration_time < Time.now.utc\n  end\n\n  def size\n    self[:size] || \"N/A\"\n  end\n\n  def byte_size\n    self[:size]\n  end\n\n  def byte_size=(size)\n    self[:size] = size.to_i\n  end\n\n  def info\n    [description, summary, \"This rubygem does not have a description or summary.\"].find(&:present?)\n  end\n\n  def update_attributes_from_gem_specification!(spec)\n    update!(\n      authors: spec.authors,\n      description: spec.description,\n      summary: spec.summary,\n      licenses: spec.licenses,\n      metadata: spec.metadata || {},\n      requirements: spec.requirements,\n      built_at: spec.date,\n      required_rubygems_version: spec.required_rubygems_version.to_s,\n      required_ruby_version: spec.required_ruby_version.to_s,\n      indexed: true\n    )\n  end\n\n  def platform_as_number\n    if platformed?\n      0\n    else\n      1\n    end\n  end\n\n  def <=>(other)\n    self_version  = to_gem_version\n    other_version = other.to_gem_version\n\n    if self_version == other_version\n      platform_as_number <=> other.platform_as_number\n    else\n      self_version <=> other_version\n    end\n  end\n\n  def slug\n    full_name.remove(/^#{rubygem.name}-/)\n  end\n\n  def downloads_count\n    gem_download&.count || 0\n  end\n\n  def payload\n    {\n      \"authors\"                    => authors,\n      \"built_at\"                   => built_at,\n      \"created_at\"                 => created_at,\n      \"description\"                => description,\n      \"downloads_count\"            => downloads_count,\n      \"metadata\"                   => metadata,\n      \"number\"                     => number,\n      \"summary\"                    => summary,\n      \"platform\"                   => platform,\n      \"rubygems_version\"           => required_rubygems_version,\n      \"ruby_version\"               => required_ruby_version,\n      \"prerelease\"                 => prerelease,\n      \"licenses\"                   => licenses,\n      \"requirements\"               => requirements,\n      \"sha\"                        => sha256_hex\n    }\n  end\n\n  def as_json(*)\n    payload\n  end\n\n  def to_xml(options = {})\n    payload.to_xml(options.merge(root: \"version\"))\n  end\n\n  def to_s\n    number\n  end\n\n  def to_title\n    if platformed?\n      \"#{rubygem.name} (#{number}-#{platform})\"\n    else\n      \"#{rubygem.name} (#{number})\"\n    end\n  end\n\n  def to_bundler(locked_version: false)\n    if prerelease?\n      modifier = locked_version ? \"\" : \"~> \"\n      %(gem '#{rubygem.name}', '#{modifier}#{number}')\n    elsif number[0] == \"0\"\n      %(gem '#{rubygem.name}', '~> #{number}')\n    else\n      release = feature_release\n      if release == Gem::Version.new(number)\n        %(gem '#{rubygem.name}', '~> #{release}')\n      else\n        %(gem '#{rubygem.name}', '~> #{release}', '>= #{number}')\n      end\n    end\n  end\n\n  def to_gem_version\n    Gem::Version.new(number)\n  end\n\n  def to_install\n    command = \"gem install #{rubygem.name}\"\n    latest = if prerelease\n               rubygem.versions.by_position.prerelease.first\n             else\n               rubygem.versions.most_recent\n             end\n    command << \" -v #{number}\" if latest != self\n    command << \" --pre\" if prerelease\n    command\n  end\n\n  def authors_array\n    authors.split(\",\").flatten\n  end\n\n  def sha256_hex\n    Version._sha256_hex(sha256) if sha256\n  end\n\n  def self._sha256_hex(raw)\n    raw.unpack1(\"m0\").unpack1(\"H*\")\n  end\n\n  def metadata_uri_set?\n    Links::LINKS.any? { |_, long| metadata.key? long }\n  end\n\n  def rubygems_metadata_mfa_required?\n    ActiveRecord::Type::Boolean.new.cast(metadata[\"rubygems_mfa_required\"])\n  end\n\n  def yanker\n    Deletion.find_by(rubygem: rubygem.name, number: number, platform: platform)&.user unless indexed\n  end\n\n  def prerelease\n    !!to_gem_version.prerelease?\n  end\n  alias prerelease? prerelease\n\n  def manifest\n    rubygem.version_manifest(number, platformed? ? platform : nil)\n  end\n\n  private\n\n  def update_prerelease\n    self[:prerelease] = prerelease\n  end\n\n  def platform_and_number_are_unique\n    return unless Version.exists?(rubygem_id: rubygem_id, number: number, platform: platform)\n    errors.add(:base, \"A version already exists with this number or platform.\")\n  end\n\n  def authors_format\n    authors = authors_before_type_cast\n    return unless authors\n    string_authors = authors.is_a?(Array) && authors.grep(String)\n    return unless string_authors.blank? || string_authors.size != authors.size\n    errors.add :authors, \"must be an Array of Strings\"\n  end\n\n  def full_nameify!\n    return if rubygem.nil?\n    self.full_name = \"#{rubygem.name}-#{number}\"\n    full_name << \"-#{platform}\" if platformed?\n  end\n\n  def set_canonical_number\n    return unless Gem::Version.correct?(number)\n    self.canonical_number = to_gem_version.canonical_segments.join(\".\")\n  end\n\n  def feature_release\n    feature_version = to_gem_version.release.segments[0, 2].join(\".\")\n    Gem::Version.new(feature_version)\n  end\n\n  def metadata_links_format\n    Linkset::LINKS.each do |link|\n      errors.add(:metadata, \"['#{link}'] does not appear to be a valid URL\") if\n        metadata[link] && metadata[link] !~ Patterns::URL_VALIDATION_REGEXP\n    end\n  end\n\n  def metadata_attribute_length\n    return if metadata.blank?\n\n    max_key_size = 128\n    max_value_size = 1024\n    metadata.each do |key, value|\n      errors.add(:metadata, \"metadata key ['#{key}'] is too large (maximum is #{max_key_size} bytes)\") if key.size > max_key_size\n      errors.add(:metadata, \"metadata value ['#{value}'] is too large (maximum is #{max_value_size} bytes)\") if value.size > max_value_size\n      errors.add(:metadata, \"metadata key is empty\") if key.empty?\n    end\n  end\n\n  def unique_canonical_number\n    version = Version.find_by(canonical_number: canonical_number, rubygem_id: rubygem_id, platform: platform)\n    errors.add(:canonical_number, \"has already been taken. Existing version: #{version.number}\") unless version.nil?\n  end\nend\n</Code>\n\nFile: lib/patterns.rb\nContent: \n<Code>\nmodule Patterns\n  extend ActiveSupport::Concern\n\n  JAVA_HTTP_USER_AGENT  = /^java/i\n  SPECIAL_CHARACTERS    = \".-_\".freeze\n  ALLOWED_CHARACTERS    = \"[A-Za-z0-9#{Regexp.escape(SPECIAL_CHARACTERS)}]+\".freeze\n  ROUTE_PATTERN         = /#{ALLOWED_CHARACTERS}/\n  LAZY_ROUTE_PATTERN    = /#{ALLOWED_CHARACTERS}?/\n  NAME_PATTERN          = /\\A#{ALLOWED_CHARACTERS}\\Z/\n  URL_VALIDATION_REGEXP = %r{\\Ahttps?://([^\\s:@]+:[^\\s:@]*@)?[A-Za-z\\d-]+(\\.[A-Za-z\\d-]+)+\\.?(:\\d{1,5})?([/?]\\S*)?\\z}\nend\n</Code>\n\nFile: test/helpers/gem_helpers.rb\nContent: \n<Code>\nmodule GemHelpers\n  def gem_specification_from_gem_fixture(name)\n    Gem::Package.new(File.join(\"test\", \"gems\", \"#{name}.gem\")).spec\n  end\n\n  def gem_file(name = \"test-0.0.0.gem\")\n    Rails.root.join(\"test\", \"gems\", name.to_s).open(\"rb\")\n  end\n\n  def build_gemspec(gemspec)\n    Gem::DefaultUserInteraction.use_ui(Gem::StreamUI.new(StringIO.new, StringIO.new)) do\n      Gem::Package.build(gemspec, true)\n    end\n  end\n\n  def build_gem(name, version, summary = \"Gemcutter\", platform = \"ruby\", &)\n    build_gemspec(new_gemspec(name, version, summary, platform, &))\n  end\n\n  def new_gemspec(name, version, summary, platform, extra_args = {})\n    ruby_version = extra_args[:ruby_version]\n    rubygems_version = extra_args[:rubygems_version]\n    Gem::Specification.new do |s|\n      s.name = name\n      s.platform = platform\n      s.version = version.to_s\n      s.authors = [\"Someone\"]\n      s.date = Time.zone.now.strftime(\"%Y-%m-%d\")\n      s.description = summary.to_s\n      s.email = \"someone@example.com\"\n      s.files = []\n      s.homepage = \"http://example.com/#{name}\"\n      s.require_paths = [\"lib\"]\n      s.summary = summary.to_s\n      s.test_files = []\n      s.licenses = []\n      s.required_ruby_version = ruby_version\n      s.required_rubygems_version = rubygems_version\n      s.metadata = { \"foo\" => \"bar\" }\n      yield s if block_given?\n    end\n  end\nend\n</Code>\n\nFile: test/integration/push_test.rb\nContent: \n<Code>\nrequire \"test_helper\"\n\nclass PushTest < ActionDispatch::IntegrationTest\n  include ActiveJob::TestHelper\n\n  setup do\n    Dir.chdir(Dir.mktmpdir)\n    @key = \"12345\"\n    @user = create(:user)\n    create(:api_key, user: @user, key: @key, push_rubygem: true)\n  end\n\n  test \"pushing a gem\" do\n    build_gem \"sandworm\", \"1.0.0\"\n\n    push_gem \"sandworm-1.0.0.gem\"\n\n    assert_response :success\n\n    get rubygem_path(\"sandworm\")\n\n    assert_response :success\n    assert page.has_content?(\"sandworm\")\n    assert page.has_content?(\"1.0.0\")\n    assert page.has_content?(\"Pushed by\")\n\n    css = %(div.gem__users a[alt=#{@user.handle}])\n\n    assert page.has_css?(css, count: 2)\n  end\n\n  test \"push a new version of a gem\" do\n    rubygem = create(:rubygem, name: \"sandworm\", number: \"1.0.0\")\n    create(:ownership, rubygem: rubygem, user: @user)\n\n    build_gem \"sandworm\", \"2.0.0\"\n\n    push_gem \"sandworm-2.0.0.gem\"\n\n    assert_response :success\n\n    refute_nil RubygemFs.instance.get(\"gems/sandworm-2.0.0.gem\")\n    refute_nil RubygemFs.instance.get(\"quick/Marshal.4.8/sandworm-2.0.0.gemspec.rz\")\n    assert_equal({ checksum_sha256: rubygem.versions.find_by!(full_name: \"sandworm-2.0.0\").sha256, key: \"gems/sandworm-2.0.0.gem\" },\n                 RubygemFs.instance.head(\"gems/sandworm-2.0.0.gem\"))\n\n    spec = Gem::Package.new(\"sandworm-2.0.0.gem\").spec\n    spec.abbreviate\n    spec.sanitize\n    spec_checksum = Digest::SHA256.base64digest Gem.deflate Marshal.dump spec\n\n    assert_equal({ checksum_sha256: spec_checksum, key: \"quick/Marshal.4.8/sandworm-2.0.0.gemspec.rz\" },\n                 RubygemFs.instance.head(\"quick/Marshal.4.8/sandworm-2.0.0.gemspec.rz\"))\n\n    get rubygem_path(\"sandworm\")\n\n    assert_response :success\n    assert page.has_content?(\"sandworm\")\n    assert page.has_content?(\"2.0.0\")\n  end\n\n  test \"pushing a gem with a known dependency\" do\n    rubygem = create(:rubygem, name: \"crysknife\", number: \"1.0.0\")\n\n    build_gem \"sandworm\", \"1.0.0\" do |gemspec|\n      gemspec.add_runtime_dependency(rubygem.name, \"> 0\")\n    end\n\n    push_gem \"sandworm-1.0.0.gem\"\n\n    get rubygem_path(\"sandworm\")\n\n    assert_response :success\n    assert page.has_content?(\"crysknife\")\n    assert page.has_content?(\"> 0\")\n  end\n\n  test \"pushing a gem with an unknown dependency\" do\n    build_gem \"sandworm\", \"1.0.0\" do |gemspec|\n      gemspec.add_runtime_dependency(\"mauddib\", \"> 1\")\n    end\n\n    push_gem \"sandworm-1.0.0.gem\"\n\n    get rubygem_path(\"sandworm\")\n\n    assert_response :success\n    assert page.has_content?(\"mauddib\")\n    assert page.has_content?(\"> 1\")\n  end\n\n  test \"pushing a signed gem\" do\n    push_gem gem_file(\"valid_signature-0.0.0.gem\")\n\n    get rubygem_path(\"valid_signature\")\n\n    assert_response :success\n\n    assert page.has_content?(\"Signature validity period\")\n    assert page.has_content?(\"August 31, 2021\")\n    assert page.has_content?(\"August 07, 2121\")\n    refute page.has_content?(\"(expired)\")\n\n    travel_to Time.zone.local(2121, 8, 8)\n    get rubygem_path(\"valid_signature\")\n\n    assert page.has_content?(\"(expired)\")\n  end\n\n  test \"push errors bubble out\" do\n    push_gem Rails.root.join(\"test\", \"gems\", \"bad-characters-1.0.0.gem\")\n\n    assert_response :unprocessable_entity\n    assert_match(/cannot process this gem/, response.body)\n    assert_nil RubygemFs.instance.get(\"gems/bad-characters-1.0.0.gem\")\n    assert_nil RubygemFs.instance.get(\"quick/Marshal.4.8/bad-characters-1.0.0.gemspec.rz\")\n  end\n\n  test \"push errors don't save files\" do\n    build_gem \"sandworm\", \"1.0.0\" do |spec|\n      spec.instance_variable_set :@authors, \"string\"\n    end\n\n    assert_nil Rubygem.find_by(name: \"sandworm\")\n    push_gem \"sandworm-1.0.0.gem\"\n\n    assert_response :internal_server_error\n    assert_match(/problem saving your gem. Please try again./, response.body)\n\n    rubygem = Rubygem.find_by(name: \"sandworm\")\n    # assert_nil rubygem\n    assert_empty rubygem.versions\n    assert_nil Version.find_by(full_name: \"sandworm-1.0.0\")\n    assert_nil RubygemFs.instance.get(\"gems/sandworm-1.0.0.gem\")\n    assert_nil RubygemFs.instance.get(\"quick/Marshal.4.8/sandworm-1.0.0.gemspec.rz\")\n  end\n\n  test \"republish a yanked version\" do\n    rubygem = create(:rubygem, name: \"sandworm\", owners: [@user])\n    create(:version, number: \"1.0.0\", indexed: false, rubygem: rubygem)\n\n    build_gem \"sandworm\", \"1.0.0\"\n\n    push_gem \"sandworm-1.0.0.gem\"\n\n    assert_response :conflict\n    assert_match(/A yanked version already exists \\(sandworm-1.0.0\\)/, response.body)\n  end\n\n  test \"republish a yanked version by a different owner\" do\n    rubygem = create(:rubygem, name: \"sandworm\")\n    create(:version, number: \"1.0.0\", indexed: false, rubygem: rubygem)\n\n    build_gem \"sandworm\", \"1.0.0\"\n\n    push_gem \"sandworm-1.0.0.gem\"\n\n    assert_response :conflict\n    assert_match(/A yanked version pushed by a previous owner of this gem already exists \\(sandworm-1.0.0\\)/, response.body)\n  end\n\n  test \"publishing a gem with ceritifcate but not signatures\" do\n    build_gem \"sandworm\", \"2.0.0\" do |gemspec|\n      gemspec.cert_chain = [File.read(File.expand_path(\"../certs/chain.pem\", __dir__))]\n    end\n\n    push_gem \"sandworm-2.0.0.gem\"\n\n    assert_response :forbidden\n    assert_match(/You have added cert_chain in gemspec but signature was empty/, response.body)\n  end\n\n  setup do\n    @act = ENV[\"HOOK_RELAY_ACCOUNT_ID\"]\n    @id = ENV[\"HOOK_RELAY_HOOK_ID\"]\n    ENV[\"HOOK_RELAY_ACCOUNT_ID\"] = \"act\"\n    ENV[\"HOOK_RELAY_HOOK_ID\"] = \"id\"\n  end\n\n  teardown do\n    ENV[\"HOOK_RELAY_ACCOUNT_ID\"] = @act\n    ENV[\"HOOK_RELAY_HOOK_ID\"] = @id\n  end\n\n  test \"publishing a gem with webhook subscribers\" do\n    hook = create(:global_web_hook)\n\n    build_gem \"sandworm\", \"2.0.0\"\n    push_gem \"sandworm-2.0.0.gem\"\n\n    assert_response :success\n\n    stub_request(:post, \"https://api.hookrelay.dev/hooks/act/id/webhook_id-#{hook.id}\").with(\n      headers: {\n        \"Content-Type\" => \"application/json\",\n        \"HR_TARGET_URL\" => hook.url,\n        \"HR_MAX_ATTEMPTS\" => \"3\"\n      }\n    ).and_return(status: 200, body: { id: :id123 }.to_json)\n    perform_enqueued_jobs only: NotifyWebHookJob\n\n    assert_predicate hook.reload.failure_count, :zero?\n\n    post hook_relay_report_api_v1_web_hooks_path,\n      params: {\n        attempts: 3,\n        account_id: \"act\",\n        hook_id: \"id\",\n        id: \"01GTE93BNWPD0VF0V4QCJ7NDSF\",\n        created_at: \"2023-03-01T09:47:18Z\",\n        request: {\n          body: \"{}\",\n            headers: {\n              Authorization: \"51bf53d06ac382585b83e6f3241c950710ee53368e948ac309b7869c974338e9\",\n                \"User-Agent\": \"rest-client/2.1.0 (darwin22 arm64) ruby/3.2.1p31\",\n                Accept: \"*/*\",\n                \"Content-Type\": \"application/json\"\n            },\n            target_url: \"https://example.com/rubygem0\"\n        },\n        report_url: \"https://rubygems.org/api/v1/web_hooks/hook_relay_report\",\n        max_attempts: 3,\n        status: \"success\",\n        last_attempted_at: \"2023-03-01T09:50:31+00:00\",\n        stream: \"hook:act:id:webhook_id-#{hook.id}\",\n        completed_at: \"2023-03-01T09:50:31+00:00\"\n      },\n      as: :json\n\n    assert_response :success\n    perform_enqueued_jobs only: HookRelayReportJob\n\n    assert_predicate hook.reload.failure_count, :zero?\n    assert_equal 1, hook.successes_since_last_failure\n    assert_equal 0, hook.failures_since_last_success\n    assert_equal \"2023-03-01T09:50:31+00:00\".to_datetime, hook.last_success\n\n    post hook_relay_report_api_v1_web_hooks_path,\n      params: {\n        attempts: 3,\n        account_id: \"act\",\n        hook_id: \"id\",\n        id: \"01GTE93BNWPD0VF0V4QCJ7NDSF\",\n        created_at: \"2023-03-01T09:47:18Z\",\n        request: {\n          body: \"{}\",\n            headers: {\n              Authorization: \"51bf53d06ac382585b83e6f3241c950710ee53368e948ac309b7869c974338e9\",\n                \"User-Agent\": \"rest-client/2.1.0 (darwin22 arm64) ruby/3.2.1p31\",\n                Accept: \"*/*\",\n                \"Content-Type\": \"application/json\"\n            },\n            target_url: \"https://example.com/rubygem0\"\n        },\n        report_url: \"https://rubygems.org/api/v1/web_hooks/hook_relay_report\",\n        max_attempts: 3,\n        status: \"failure\",\n        last_attempted_at: \"2023-03-01T09:50:31+00:00\",\n        stream: \"hook:act:id:webhook_id-#{hook.id}\",\n        failure_reason: \"Exhausted attempts\",\n        completed_at: \"2023-03-01T09:51:31+00:00\"\n      },\n      as: :json\n\n    assert_response :success\n    perform_enqueued_jobs only: HookRelayReportJob\n\n    assert_equal 1, hook.reload.failure_count\n    assert_equal 0, hook.successes_since_last_failure\n    assert_equal 1, hook.failures_since_last_success\n    assert_equal \"2023-03-01T09:50:31+00:00\".to_datetime, hook.last_success\n    assert_equal \"2023-03-01T09:51:31+00:00\".to_datetime, hook.last_failure\n  end\n\n  def push_gem(path)\n    post api_v1_rubygems_path,\n      env: { \"RAW_POST_DATA\" => File.read(path) },\n      headers: { \"CONTENT_TYPE\" => \"application/octet-stream\",\n                 \"HTTP_AUTHORIZATION\" => @key }\n  end\n\n  teardown do\n    RubygemFs.mock!\n    Dir.chdir(Rails.root)\n  end\nend\n</Code>\n\nFile: test/models/pusher_test.rb\nContent: \n<Code>\nrequire \"test_helper\"\n\nclass PusherTest < ActiveSupport::TestCase\n  include ActiveJob::TestHelper\n\n  setup do\n    @user = create(:user, email: \"user@example.com\")\n    @gem = gem_file\n    @cutter = Pusher.new(@user, @gem)\n  end\n\n  context \"creating a new gemcutter\" do\n    should \"have some state\" do\n      assert_respond_to @cutter, :user\n      assert_respond_to @cutter, :version\n      assert_respond_to @cutter, :version_id\n      assert_respond_to @cutter, :spec\n      assert_respond_to @cutter, :message\n      assert_respond_to @cutter, :code\n      assert_respond_to @cutter, :rubygem\n      assert_respond_to @cutter, :body\n\n      assert_equal @user, @cutter.user\n    end\n\n    should \"initialize size from the gem\" do\n      assert_equal @gem.size, @cutter.size\n    end\n\n    context \"processing incoming gems\" do\n      should \"work normally when things go well\" do\n        @cutter.stubs(:pull_spec).returns true\n        @cutter.stubs(:find).returns true\n        @cutter.stubs(:authorize).returns true\n        @cutter.stubs(:verify_mfa_requirement).returns true\n        @cutter.stubs(:verify_gem_scope).returns true\n        @cutter.stubs(:validate).returns true\n        @cutter.stubs(:save)\n\n        @cutter.process\n      end\n\n      should \"not attempt to find rubygem if spec can't be pulled\" do\n        @cutter.stubs(:pull_spec).returns false\n        @cutter.stubs(:find).never\n        @cutter.stubs(:authorize).never\n        @cutter.stubs(:verify_gem_scope).never\n        @cutter.stubs(:verify_mfa_requirement).never\n        @cutter.stubs(:save).never\n        @cutter.process\n      end\n\n      should \"not attempt to authorize if not found\" do\n        @cutter.stubs(:pull_spec).returns true\n        @cutter.stubs(:find)\n        @cutter.stubs(:authorize).never\n        @cutter.stubs(:verify_gem_scope).never\n        @cutter.stubs(:verify_mfa_requirement).never\n        @cutter.stubs(:save).never\n\n        @cutter.process\n      end\n\n      should \"not attempt to check gem scope if not authorized\" do\n        @cutter.stubs(:pull_spec).returns true\n        @cutter.stubs(:find).returns true\n        @cutter.stubs(:authorize).returns false\n        @cutter.stubs(:verify_gem_scope).never\n        @cutter.stubs(:verify_mfa_requirement).never\n        @cutter.stubs(:validate).never\n        @cutter.stubs(:save).never\n\n        @cutter.process\n      end\n\n      should \"not attempt to check mfa requirement if scoped to another gem\" do\n        @cutter.stubs(:pull_spec).returns true\n        @cutter.stubs(:find).returns true\n        @cutter.stubs(:authorize).returns true\n        @cutter.stubs(:verify_gem_scope).returns false\n        @cutter.stubs(:verify_mfa_requirement).never\n        @cutter.stubs(:validate).never\n        @cutter.stubs(:save).never\n\n        @cutter.process\n      end\n\n      should \"not attempt to validate if mfa check failed\" do\n        @cutter.stubs(:pull_spec).returns true\n        @cutter.stubs(:find).returns true\n        @cutter.stubs(:authorize).returns true\n        @cutter.stubs(:verify_gem_scope).returns true\n        @cutter.stubs(:verify_mfa_requirement).returns false\n        @cutter.stubs(:validate).never\n        @cutter.stubs(:save).never\n\n        @cutter.process\n      end\n\n      should \"not attempt to save if not validated\" do\n        @cutter.stubs(:pull_spec).returns true\n        @cutter.stubs(:find).returns true\n        @cutter.stubs(:authorize).returns true\n        @cutter.stubs(:verify_gem_scope).returns true\n        @cutter.stubs(:verify_mfa_requirement).returns true\n        @cutter.stubs(:validate).returns false\n        @cutter.stubs(:save).never\n\n        @cutter.process\n      end\n    end\n\n    should \"not be able to pull spec from a bad path\" do\n      @cutter.stubs(:body).stubs(:stub!).stubs(:read)\n      @cutter.pull_spec\n\n      assert_nil @cutter.spec\n      assert_match(/RubyGems\\.org cannot process this gem/, @cutter.message)\n      assert_equal 422, @cutter.code\n    end\n\n    should \"not be able to pull spec with metadata containing bad ruby objects\" do\n      @gem = gem_file(\"exploit.gem\")\n      @cutter = Pusher.new(@user, @gem)\n      out, err = capture_io do\n        @cutter.pull_spec\n      end\n\n      assert_equal \"\", out\n      assert_equal(\"Exception while verifying \\n\", err)\n      assert_nil @cutter.spec\n      assert_match(/RubyGems\\.org cannot process this gem/, @cutter.message)\n      assert_match(/ActionController::Routing::RouteSet::NamedRouteCollection/, @cutter.message)\n      assert_equal 422, @cutter.code\n    end\n\n    should \"not be able to save a gem if it is not valid\" do\n      legit_gem = create(:rubygem, name: \"legit-gem\")\n      create(:version, rubygem: legit_gem, number: \"0.0.1\")\n      @gem = gem_file(\"legit-gem-0.0.1.gem.fake\")\n      @cutter = Pusher.new(@user, @gem)\n      @cutter.stubs(:save).never\n      @cutter.process\n\n      assert_equal(\"legit\", @cutter.rubygem.name)\n      assert_equal(\"gem-0.0.1\", @cutter.version.number)\n      assert_match(/There was a problem saving your gem: Number is invalid/, @cutter.message)\n      assert_equal 403, @cutter.code\n    end\n\n    should \"not be able to save a gem if the date is not valid\" do\n      @gem = gem_file(\"bad-date-1.0.0.gem\")\n      @cutter = Pusher.new(@user, @gem)\n      out, err = capture_io do\n        @cutter.process\n      end\n\n      assert_equal \"\", out\n      assert_equal(\"Exception while verifying \\n\", err)\n      assert_match(/mon out of range/, @cutter.message)\n      assert_equal 422, @cutter.code\n    end\n\n    should \"not be able to save a gem if it is signed and has been tampered with\" do\n      @gem = gem_file(\"valid_signature_tampered-0.0.1.gem\")\n      @cutter = Pusher.new(@user, @gem)\n      @cutter.process\n\n      assert_includes @cutter.message, %(missing signing certificate)\n      assert_equal 422, @cutter.code\n    end\n\n    should \"not be able to save a gem if it is signed with an expired signing certificate\" do\n      @gem = gem_file(\"expired_signature-0.0.0.gem\")\n      @cutter = Pusher.new(@user, @gem)\n      @cutter.process\n\n      assert_includes @cutter.message, %(not valid after 2021-07-08 08:21:01 UTC)\n      assert_equal 422, @cutter.code\n    end\n\n    context \"for a signed gem having two certificates in the chain\" do\n      setup do\n        Dir.chdir(Dir.mktmpdir)\n      end\n\n      should \"be able to save the gem if the chain is valid\" do\n        gem_file = build_gem(\"valid_cert_chain\", \"0.0.0\") do |spec|\n          signing_key = OpenSSL::PKey::RSA.new(1024)\n          spec.signing_key = signing_key\n          spec.cert_chain = two_cert_chain(signing_key: signing_key)\n        end\n\n        @cutter = Pusher.new(@user, File.open(gem_file))\n        @cutter.process\n\n        assert_equal 200, @cutter.code\n      end\n\n      should \"not be able to save the gem if the root certificate has expired\" do\n        begin\n          old_verify_root_policy = Gem::Security::SigningPolicy.verify_root\n          Gem::Security::SigningPolicy.verify_root = false\n          signing_key = OpenSSL::PKey::RSA.new(1024)\n\n          gem_file = build_gem(\"expired_root_cert\", \"0.0.0\") do |spec|\n            spec.signing_key = signing_key\n            spec.cert_chain = two_cert_chain(signing_key: signing_key, root_not_before: 2.years.ago)\n          end\n        ensure\n          Gem::Security::SigningPolicy.verify_root = old_verify_root_policy\n        end\n\n        @cutter = Pusher.new(@user, File.open(gem_file))\n        @cutter.process\n\n        assert_includes @cutter.message, %(CN=Root not valid after)\n        assert_equal(422, @cutter.code)\n      end\n\n      teardown do\n        Dir.chdir(Rails.root)\n      end\n    end\n\n    should \"not be able to pull spec with metadata containing bad ruby symbols\" do\n      [\"1.0.0\", \"2.0.0\", \"3.0.0\", \"4.0.0\"].each do |version|\n        @gem = gem_file(\"dos-#{version}.gem\")\n        @cutter = Pusher.new(@user, @gem)\n        out, err = capture_io do\n          @cutter.pull_spec\n        end\n\n        assert_equal \"\", out\n        assert_equal(\"Exception while verifying \\n\", err)\n        assert_nil @cutter.spec\n        assert_includes @cutter.message, %(RubyGems.org cannot process this gem)\n        assert_includes @cutter.message, %(Tried to load unspecified class: Symbol)\n        assert_equal 422, @cutter.code\n      end\n    end\n\n    should \"be able to pull spec with metadata containing aliases\" do\n      @gem = gem_file(\"aliases-0.0.0.gem\")\n      @cutter = Pusher.new(@user, @gem)\n      @cutter.pull_spec\n\n      assert_not_nil @cutter.spec\n      assert_not_nil @cutter.spec.dependencies.first.requirement\n    end\n\n    should \"not be able to pull spec when no data available\" do\n      @gem = gem_file(\"aliases-nodata-0.0.1.gem\")\n      @cutter = Pusher.new(@user, @gem)\n      @cutter.pull_spec\n\n      assert_includes @cutter.message, %{package content (data.tar.gz) is missing}\n    end\n  end\n\n  def two_cert_chain(signing_key:, root_not_before: Time.current, cert_not_before: Time.current)\n    root_key = OpenSSL::PKey::RSA.new(1024)\n    root_subject = \"/C=FI/O=Test/OU=Test/CN=Root\"\n\n    root_cert = OpenSSL::X509::Certificate.new\n    root_cert.subject = root_cert.issuer = OpenSSL::X509::Name.parse(root_subject)\n    root_cert.not_before = root_not_before\n    root_cert.not_after = root_not_before + 1.year\n    root_cert.public_key = root_key.public_key\n    root_cert.serial = 0x0\n    root_cert.version = 2\n    root_cert.sign(root_key, OpenSSL::Digest.new(\"SHA256\"))\n\n    subject = \"/C=FI/O=Test/OU=Test/CN=Test\"\n\n    cert = OpenSSL::X509::Certificate.new\n    cert.issuer = OpenSSL::X509::Name.parse(root_subject)\n    cert.subject = OpenSSL::X509::Name.parse(subject)\n    cert.not_before = cert_not_before\n    cert.not_after = cert_not_before + 1.year\n    cert.public_key = signing_key.public_key\n    cert.serial = 0x0\n    cert.version = 2\n    cert.sign(root_key, OpenSSL::Digest.new(\"SHA256\"))\n\n    [root_cert, cert]\n  end\n\n  context \"initialize new gem with find if one does not exist\" do\n    setup do\n      spec = mock\n      spec.expects(:name).returns \"some name\"\n      spec.expects(:version).returns Gem::Version.new(\"1.3.3.7\")\n      spec.expects(:original_platform).returns \"ruby\"\n      spec.expects(:cert_chain).returns nil\n      @cutter.stubs(:spec).returns spec\n      @cutter.stubs(:size).returns 5\n      @cutter.stubs(:body).returns StringIO.new(\"dummy body\")\n\n      @cutter.find\n    end\n\n    should \"set rubygem\" do\n      assert_equal \"some name\", @cutter.rubygem.name\n    end\n\n    should \"set version\" do\n      assert_equal \"1.3.3.7\", @cutter.version.number\n    end\n\n    should \"set gem version size\" do\n      assert_equal 5, @cutter.version.size\n    end\n\n    should \"set sha256\" do\n      expected_sha = Digest::SHA2.base64digest(@cutter.body.string)\n\n      assert_equal expected_sha, @cutter.version.sha256\n    end\n  end\n\n  context \"finding an existing gem\" do\n    should \"bring up existing gem with matching spec\" do\n      @rubygem = create(:rubygem)\n      spec = mock\n      spec.stubs(:name).returns @rubygem.name\n      spec.stubs(:version).returns Gem::Version.new(\"1.3.3.7\")\n      spec.stubs(:original_platform).returns \"ruby\"\n      spec.stubs(:cert_chain).returns nil\n      spec.stubs(:metadata).returns({})\n      @cutter.stubs(:spec).returns spec\n      @cutter.find\n\n      assert_equal @rubygem, @cutter.rubygem\n      assert_not_nil @cutter.version\n    end\n\n    should \"error out when changing case with usuable versions\" do\n      @rubygem = create(:rubygem)\n      create(:version, rubygem: @rubygem)\n\n      assert_not_equal @rubygem.name, @rubygem.name.upcase\n\n      spec = mock\n      spec.expects(:name).returns @rubygem.name.upcase\n      spec.expects(:version).returns Gem::Version.new(\"1.3.3.7\")\n      spec.expects(:original_platform).returns \"ruby\"\n      @cutter.stubs(:spec).returns spec\n\n      refute @cutter.find\n\n      assert_match(/Unable to change case/, @cutter.message)\n    end\n\n    should \"update the DB to reflect the case in the spec\" do\n      @rubygem = create(:rubygem)\n\n      assert_not_equal @rubygem.name, @rubygem.name.upcase\n\n      spec = mock\n      spec.stubs(:name).returns @rubygem.name.upcase\n      spec.stubs(:version).returns Gem::Version.new(\"1.3.3.7\")\n      spec.stubs(:original_platform).returns \"ruby\"\n      spec.stubs(:cert_chain).returns nil\n      spec.stubs(:metadata).returns({})\n      @cutter.stubs(:spec).returns spec\n      @cutter.find\n\n      @cutter.rubygem.save\n      @rubygem.reload\n\n      assert_equal @rubygem.name.upcase, @rubygem.name\n    end\n  end\n\n  context \"checking if the rubygem can be pushed to\" do\n    should \"be true if rubygem is new\" do\n      @cutter.stubs(:rubygem).returns Rubygem.new\n\n      assert @cutter.authorize\n    end\n\n    context \"with a existing rubygem\" do\n      setup do\n        @rubygem = create(:rubygem, name: \"the_gem_name\")\n        @cutter.stubs(:rubygem).returns @rubygem\n      end\n\n      should \"be true if owned by the user\" do\n        create(:ownership, rubygem: @rubygem, user: @user)\n\n        assert @cutter.authorize\n      end\n\n      should \"be true if no versions exist since it's a dependency\" do\n        assert @cutter.authorize\n      end\n\n      should \"be false if not owned by user and an indexed version exists\" do\n        create(:version, rubygem: @rubygem, number: \"0.1.1\")\n\n        refute @cutter.authorize\n        assert_equal \"You do not have permission to push to this gem. Ask an owner to add you with: gem owner the_gem_name --add user@example.com\",\n          @cutter.message\n        assert_equal 403, @cutter.code\n      end\n\n      should \"be true if not owned by user but no indexed versions exist\" do\n        create(:version, rubygem: @rubygem, number: \"0.1.1\", indexed: false)\n\n        assert @cutter.authorize\n      end\n\n      context \"version metadata has rubygems_mfa_required set\" do\n        setup do\n          spec = mock\n          spec.expects(:metadata).returns({ \"rubygems_mfa_required\" => true })\n          @cutter.stubs(:spec).returns spec\n\n          metadata = { \"rubygems_mfa_required\" => \"true\" }\n          create(:version, rubygem: @rubygem, number: \"0.1.1\", metadata: metadata)\n        end\n\n        should \"be false if user has no mfa setup\" do\n          refute @cutter.verify_mfa_requirement\n        end\n      end\n    end\n  end\n\n  context \"successfully saving a gemcutter\" do\n    setup do\n      @rubygem = create(:rubygem, name: \"gemsgemsgems\")\n      @cutter.stubs(:rubygem).returns @rubygem\n      create(:version, rubygem: @rubygem, number: \"0.1.1\", summary: \"old summary\")\n      @spec = mock\n      @cutter.stubs(:version).returns @rubygem.versions[0]\n      @cutter.stubs(:spec).returns(@spec)\n      @rubygem.stubs(:update_attributes_from_gem_specification!)\n      @cutter.stubs(:write_gem)\n    end\n\n    context \"when cutter is saved\" do\n      setup do\n        assert @cutter.save\n      end\n\n      should \"set gem file size\" do\n        assert_equal @gem.size, @cutter.size\n      end\n\n      should \"set success code\" do\n        assert_equal 200, @cutter.code\n      end\n\n      should \"set info_checksum\" do\n        assert_not_nil @rubygem.versions.last.info_checksum\n      end\n\n      should \"indexe rubygem and version\" do\n        assert_predicate @rubygem, :indexed?\n        assert_predicate @rubygem.versions.last, :indexed?\n      end\n\n      should \"create rubygem index\" do\n        @rubygem.update_column(\"updated_at\", Date.new(2016, 07, 04))\n        perform_enqueued_jobs only: ReindexRubygemJob\n        response = Searchkick.client.get index: \"rubygems-#{Rails.env}\",\n                                         id:    @rubygem.id\n        expected_response = {\n          \"name\"              => \"gemsgemsgems\",\n          \"downloads\"         => 0,\n          \"version\"           => \"0.1.1\",\n          \"version_downloads\" => 0,\n          \"platform\"          => \"ruby\",\n          \"authors\"           => \"Joe User\",\n          \"info\"              => \"Some awesome gem\",\n          \"licenses\"          => \"MIT\",\n          \"metadata\"          => { \"foo\" => \"bar\" },\n          \"sha\"               => \"b5d4045c3f466fa91fe2cc6abe79232a1a57cdf104f7a26e716e0a1e2789df78\",\n          \"project_uri\"       => \"http://localhost/gems/gemsgemsgems\",\n          \"gem_uri\"           => \"http://localhost/gems/gemsgemsgems-0.1.1.gem\",\n          \"homepage_uri\"      => \"http://example.com\",\n          \"wiki_uri\"          => \"http://example.com\",\n          \"documentation_uri\" => \"http://example.com\",\n          \"mailing_list_uri\"  => \"http://example.com\",\n          \"source_code_uri\"   => \"http://example.com\",\n          \"bug_tracker_uri\"   => \"http://example.com\",\n          \"changelog_uri\"     => nil,\n          \"funding_uri\"       => nil,\n          \"yanked\"            => false,\n          \"summary\"           => \"old summary\",\n          \"description\"       => \"Some awesome gem\",\n          \"updated\"           => \"2016-07-04T00:00:00.000Z\",\n          \"dependencies\"      => { \"development\" => [], \"runtime\" => [] },\n          \"suggest\"           => { \"input\" => \"gemsgemsgems\", \"weight\" => 0, \"contexts\" => { \"yanked\" => false } }\n        }\n\n        assert_equal expected_response, response[\"_source\"]\n      end\n    end\n\n    should \"purge gem cache\" do\n      GemCachePurger.expects(:call).with(@rubygem.name).at_least_once\n      @cutter.save\n    end\n\n    should \"update rubygem attributes when saved\" do\n      @rubygem.expects(:update_attributes_from_gem_specification!).with(@cutter.version, @spec)\n      @cutter.save\n    end\n\n    should \"enqueue job for email, updating ES index, spec index and purging cdn\" do\n      assert_enqueued_jobs 1, only: ActionMailer::MailDeliveryJob do\n        assert_enqueued_jobs 6, only: FastlyPurgeJob do\n          assert_enqueued_jobs 1, only: Indexer do\n            assert_enqueued_jobs 1, only: ReindexRubygemJob do\n              @cutter.save\n            end\n          end\n        end\n      end\n    end\n\n    # TODO: Remove this test once this is always enabled\n    should \"not enqueue job for storing version contents when ENV disables it\" do\n      assert_enqueued_jobs 0, only: StoreVersionContentsJob do\n        @cutter.save\n      end\n    end\n  end\n\n  context \"pushing a new version\" do\n    setup do\n      @rubygem = create(:rubygem)\n      @cutter.stubs(:rubygem).returns @rubygem\n      create(:version, rubygem: @rubygem, summary: \"old summary\")\n      @version = create(:version, rubygem: @rubygem, summary: \"new summary\")\n      @cutter.stubs(:version).returns @version\n      @rubygem.stubs(:update_attributes_from_gem_specification!)\n      @cutter.stubs(:version).returns @version\n      GemCachePurger.stubs(:call)\n      @cutter.stubs(:write_gem)\n      @cutter.save\n    end\n\n    should \"update rubygem index\" do\n      perform_enqueued_jobs only: ReindexRubygemJob\n      response = Searchkick.client.get index: \"rubygems-#{Rails.env}\",\n                                       id:    @rubygem.id\n\n      assert_equal \"new summary\", response[\"_source\"][\"summary\"]\n    end\n\n    should \"send gem pushed email\" do\n      perform_enqueued_jobs only: ActionMailer::MailDeliveryJob\n\n      email = ActionMailer::Base.deliveries.last\n\n      assert_equal \"Gem #{@version.to_title} pushed to RubyGems.org\", email.subject\n      assert_equal [@user.email], email.to\n    end\n  end\n\n  context \"pushing to s3 fails\" do\n    setup do\n      @gem = gem_file(\"test-1.0.0.gem\")\n      @cutter = Pusher.new(@user, @gem)\n      @fs = RubygemFs.s3!(\"https://some.host\")\n      s3_exception = Aws::S3::Errors::ServiceError.new(\"stub raises\", \"something went wrong\")\n      Aws::S3::Client.any_instance.stubs(:put_object).with(any_parameters).raises(s3_exception)\n      @cutter.process\n    end\n\n    should \"not create version\" do\n      rubygem = Rubygem.find_by(name: \"test\")\n      expected_message = \"There was a problem saving your gem. Please try again.\"\n\n      assert_equal expected_message, @cutter.message\n      assert_equal 0, rubygem.versions.count\n    end\n\n    teardown { RubygemFs.mock! }\n  end\n\n  context \"has a scoped gem\" do\n    setup do\n      @rubygem = create(:rubygem)\n    end\n\n    should \"pushes gem if scoped to the same gem\" do\n      create(:version, rubygem: @rubygem, number: \"0.1.1\", indexed: false)\n      cutter = Pusher.new(@user, @gem, \"\", @rubygem)\n      cutter.stubs(:rubygem).returns @rubygem\n\n      assert cutter.verify_gem_scope\n    end\n\n    should \"does not push gem if scoped to another gem\" do\n      create(:version, rubygem: @rubygem, number: \"0.1.1\", indexed: false)\n      cutter = Pusher.new(@user, @gem, \"\", create(:rubygem))\n      cutter.stubs(:rubygem).returns @rubygem\n\n      refute cutter.verify_gem_scope\n    end\n  end\n\n  context \"the gem has been signed and not tampered with\" do\n    setup do\n      @gem = gem_file(\"valid_signature-0.0.0.gem\")\n      @cutter = Pusher.new(@user, @gem)\n      @cutter.process\n    end\n\n    should \"extracts the certificate chain to the version\" do\n      assert_equal 200, @cutter.code\n      assert_not_nil @cutter.version\n      assert_not_nil @cutter.version.cert_chain\n      assert_equal 1, @cutter.version.cert_chain.size\n      assert_equal \"CN=snakeoil/DC=example/DC=invalid\", @cutter.version.cert_chain.first.subject.to_utf8\n    end\n\n    teardown { RubygemFs.mock! }\n  end\nend\n</Code>\n\n"
                }
            ],
            "llm_raw_output": "{\n  \"CWE_IDS\": [\"CWE-326\"],\n  \"severity\": null\n}",
            "llm_output": {
                "CWE_IDS": [
                    "CWE-326"
                ],
                "severity": null
            },
            "ground_truth_CVE": "CVE-2023-40165",
            "ground_truth_CWEs": [
                "CWE-20"
            ],
            "ground_truth_severities": {
                "V3.1": "HIGH"
            },
            "ground_truth_CVSS_version": [
                "V3.1"
            ],
            "is_equal": false,
            "error_msg": null,
            "equal_severity": false,
            "cwe_evaluation": "NOT_OVERLAPPED"
        },
        {
            "llm_input": [
                {
                    "role": "system",
                    "content": "You are an expert in identifying Common Weakness Enumerations (CWEs) and assessing the severity of vulnerabilities in software code.\n\nInstructions:\n1. * Input: You will receive one or more files, each has a file name, and file content enclosed  within <Code> and </Code>. If there are multiple buggy codes, they will be related to the same bug. The provided input structure is as below:\n   File: file_name\n   Content: <Code> content </Code>\n2. * Output: Generate a JSON object with the following structure:\n   {\n     \"CWE_IDS\": [], \n     \"severity\": null\n   }\n\nOutput Details:\n- CWE_IDS: If you identify any CWE IDs in the provided buggy code(s), list them here (e.g., [\"CWE-123\"]). If no CWEs are found, leave this as an empty array [].\n- severity: If the buggy code(s) has a security vulnerability (CVE), provide its severity level (e.g., \"high\") based on CVSS V3.1 . If there are no vulnerabilities, set this field to null.\n\nExample Outputs:\n1. If CWEs are found and severity is identified:\n   {\n     \"CWE_IDS\": [\"CWE-123\", \"CWE-456\"],\n     \"severity\": \"high\"\n   }\n\n2. If no CWEs or severity are identified:\n   {\n     \"CWE_IDS\": [],\n     \"severity\": null\n   }\n\nImportant: Your output must strictly follow the described JSON structure. Do not include any additional fields, descriptions, or text.\n\nCVSS v3.1 Guide:\n\nBase Metrics:\n1.\tAttack Vector (AV): How the vulnerability is exploited (Network (N), Adjacent Network (A), Local (L), Physical (P))\n2.\tAttack Complexity (AC): Difficulty of exploitation (Low (L), High (H))\n3.\tPrivileges Required (PR): Level of required privileges an attacker needs to exploit the vulnerability (None (N), Low (L), High (H))\n4.\tUser Interaction (UI): Need for user interaction (None (N), Required (R))\n5.\tScope (S): Impact on other components (Unchanged (U), Changed (C))\n6.\tConfidentiality (C), Integrity (I), Availability (A): Impact on security properties (None (N), Low (L), High (H))\n\nSeverity Levels and Example Combinations:\n1. None (0.0): This vulnerability is extremely difficult to exploit and has minimal impact. For example, \u201cAV:P/AC:H/PR:H/UI:R/S:U/C:N/I:N/A:N\u201d and \u201cAV:N/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:N\u201d\n2. Low (0.1 - 3.9): These vulnerabilities are somewhat difficult to exploit or have limited impact. For example, \u201cAV:L/AC:H/PR:L/UI:R/S:U/C:L/I:N/A:L\u201d and \u201cAV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N\u201d\n3. Medium (4.0 - 6.9): Involves vulnerabilities that are exploitable and could cause moderate damage. For example, \u201cAV:N/AC:H/PR:H/UI:R/S:C/C:L/I:L/A:N\u201d and \u201cAV:A/AC:L/PR:L/UI:N/S:U/C:L/I:H/A:L\u201d\n4. High (7.0 - 8.9): Represents vulnerabilities that are easier to exploit and have significant consequences. For example, \u201cAV:L/AC:H/PR:L/UI:N/S:C/C:H/I:L/A:L\u201d and \u201cAV:A/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:L\u201d\n5. Critical (9.0 - 10.0): These vulnerabilities are both easy to exploit and have a devastating impact. For example, \u201cAV:A/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H\u201d and \u201cAV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H\u201d\n\nNote: The severity level may change based on specific characteristics of the vulnerability. For example, if the attack vector is physical but the impact on availability is high, the severity might increase.\n                              \n"
                },
                {
                    "role": "user",
                    "content": "File: framework/core/js/src/forum/components/AvatarEditor.js\nContent: \n<Code>\nimport app from '../../forum/app';\nimport Component from '../../common/Component';\nimport avatar from '../../common/helpers/avatar';\nimport icon from '../../common/helpers/icon';\nimport listItems from '../../common/helpers/listItems';\nimport ItemList from '../../common/utils/ItemList';\nimport classList from '../../common/utils/classList';\nimport Button from '../../common/components/Button';\nimport LoadingIndicator from '../../common/components/LoadingIndicator';\n\n/**\n * The `AvatarEditor` component displays a user's avatar along with a dropdown\n * menu which allows the user to upload/remove the avatar.\n *\n * ### Attrs\n *\n * - `className`\n * - `user`\n */\nexport default class AvatarEditor extends Component {\n  oninit(vnode) {\n    super.oninit(vnode);\n\n    /**\n     * Whether or not an avatar upload is in progress.\n     *\n     * @type {Boolean}\n     */\n    this.loading = false;\n\n    /**\n     * Whether or not an image has been dragged over the dropzone.\n     *\n     * @type {Boolean}\n     */\n    this.isDraggedOver = false;\n  }\n\n  view() {\n    const user = this.attrs.user;\n\n    return (\n      <div className={classList(['AvatarEditor', 'Dropdown', this.attrs.className, this.loading && 'loading', this.isDraggedOver && 'dragover'])}>\n        {avatar(user, { loading: 'eager' })}\n        <a\n          className={user.avatarUrl() ? 'Dropdown-toggle' : 'Dropdown-toggle AvatarEditor--noAvatar'}\n          title={app.translator.trans('core.forum.user.avatar_upload_tooltip')}\n          data-toggle=\"dropdown\"\n          onclick={this.quickUpload.bind(this)}\n          ondragover={this.enableDragover.bind(this)}\n          ondragenter={this.enableDragover.bind(this)}\n          ondragleave={this.disableDragover.bind(this)}\n          ondragend={this.disableDragover.bind(this)}\n          ondrop={this.dropUpload.bind(this)}\n        >\n          {this.loading ? (\n            <LoadingIndicator display=\"unset\" size=\"large\" />\n          ) : user.avatarUrl() ? (\n            icon('fas fa-pencil-alt')\n          ) : (\n            icon('fas fa-plus-circle')\n          )}\n        </a>\n        <ul className=\"Dropdown-menu Menu\">{listItems(this.controlItems().toArray())}</ul>\n      </div>\n    );\n  }\n\n  /**\n   * Get the items in the edit avatar dropdown menu.\n   *\n   * @return {ItemList<import('mithril').Children>}\n   */\n  controlItems() {\n    const items = new ItemList();\n\n    items.add(\n      'upload',\n      <Button icon=\"fas fa-upload\" onclick={this.openPicker.bind(this)}>\n        {app.translator.trans('core.forum.user.avatar_upload_button')}\n      </Button>\n    );\n\n    items.add(\n      'remove',\n      <Button icon=\"fas fa-times\" onclick={this.remove.bind(this)}>\n        {app.translator.trans('core.forum.user.avatar_remove_button')}\n      </Button>\n    );\n\n    return items;\n  }\n\n  /**\n   * Enable dragover style\n   *\n   * @param {DragEvent} e\n   */\n  enableDragover(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    this.isDraggedOver = true;\n  }\n\n  /**\n   * Disable dragover style\n   *\n   * @param {DragEvent} e\n   */\n  disableDragover(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    this.isDraggedOver = false;\n  }\n\n  /**\n   * Upload avatar when file is dropped into dropzone.\n   *\n   * @param {DragEvent} e\n   */\n  dropUpload(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    this.isDraggedOver = false;\n    this.upload(e.dataTransfer.files[0]);\n  }\n\n  /**\n   * If the user doesn't have an avatar, there's no point in showing the\n   * controls dropdown, because only one option would be viable: uploading.\n   * Thus, when the avatar editor's dropdown toggle button is clicked, we prompt\n   * the user to upload an avatar immediately.\n   *\n   * @param {MouseEvent} e\n   */\n  quickUpload(e) {\n    if (!this.attrs.user.avatarUrl()) {\n      e.preventDefault();\n      e.stopPropagation();\n      this.openPicker();\n    }\n  }\n\n  /**\n   * Upload avatar using file picker\n   */\n  openPicker() {\n    if (this.loading) return;\n\n    // Create a hidden HTML input element and click on it so the user can select\n    // an avatar file. Once they have, we will upload it via the API.\n    const $input = $('<input type=\"file\" accept=\".jpg, .jpeg, .png, .bmp, .gif\">');\n\n    $input\n      .appendTo('body')\n      .hide()\n      .click()\n      .on('input', (e) => {\n        this.upload($(e.target)[0].files[0]);\n      });\n  }\n\n  /**\n   * Upload avatar\n   *\n   * @param {File} file\n   */\n  upload(file) {\n    if (this.loading) return;\n\n    const user = this.attrs.user;\n    const data = new FormData();\n    data.append('avatar', file);\n\n    this.loading = true;\n    m.redraw();\n\n    app\n      .request({\n        method: 'POST',\n        url: `${app.forum.attribute('apiUrl')}/users/${user.id()}/avatar`,\n        serialize: (raw) => raw,\n        body: data,\n      })\n      .then(this.success.bind(this), this.failure.bind(this));\n  }\n\n  /**\n   * Remove the user's avatar.\n   */\n  remove() {\n    const user = this.attrs.user;\n\n    this.loading = true;\n    m.redraw();\n\n    app\n      .request({\n        method: 'DELETE',\n        url: `${app.forum.attribute('apiUrl')}/users/${user.id()}/avatar`,\n      })\n      .then(this.success.bind(this), this.failure.bind(this));\n  }\n\n  /**\n   * After a successful upload/removal, push the updated user data into the\n   * store, and force a recomputation of the user's avatar color.\n   *\n   * @param {object} response\n   * @protected\n   */\n  success(response) {\n    app.store.pushPayload(response);\n    delete this.attrs.user.avatarColor;\n\n    this.loading = false;\n    m.redraw();\n  }\n\n  /**\n   * If avatar upload/removal fails, stop loading.\n   *\n   * @param {object} response\n   * @protected\n   */\n  failure(response) {\n    this.loading = false;\n    m.redraw();\n  }\n}\n</Code>\n\nFile: framework/core/src/Api/Controller/UploadFaviconController.php\nContent: \n<Code>\n<?php\n\n/*\n * This file is part of Flarum.\n *\n * For detailed copyright and license information, please view the\n * LICENSE file that was distributed with this source code.\n */\n\nnamespace Flarum\\Api\\Controller;\n\nuse Flarum\\Foundation\\ValidationException;\nuse Flarum\\Settings\\SettingsRepositoryInterface;\nuse Illuminate\\Contracts\\Filesystem\\Factory;\nuse Intervention\\Image\\Image;\nuse Intervention\\Image\\ImageManager;\nuse Psr\\Http\\Message\\UploadedFileInterface;\nuse Symfony\\Contracts\\Translation\\TranslatorInterface;\n\nclass UploadFaviconController extends UploadImageController\n{\n    protected $filePathSettingKey = 'favicon_path';\n\n    protected $filenamePrefix = 'favicon';\n\n    /**\n     * @var TranslatorInterface\n     */\n    protected $translator;\n\n    /**\n     * @var ImageManager\n     */\n    protected $imageManager;\n\n    /**\n     * @param SettingsRepositoryInterface $settings\n     * @param Factory $filesystemFactory\n     */\n    public function __construct(SettingsRepositoryInterface $settings, Factory $filesystemFactory, TranslatorInterface $translator, ImageManager $imageManager)\n    {\n        parent::__construct($settings, $filesystemFactory);\n\n        $this->translator = $translator;\n        $this->imageManager = $imageManager;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function makeImage(UploadedFileInterface $file): Image\n    {\n        $this->fileExtension = pathinfo($file->getClientFilename(), PATHINFO_EXTENSION);\n\n        if ($this->fileExtension === 'ico') {\n            // @todo remove in 2.0\n            throw new ValidationException([\n                'message' => strtr($this->translator->trans('validation.mimes'), [\n                    ':attribute' => 'favicon',\n                    ':values' => 'jpeg,png,gif,webp',\n                ])\n            ]);\n        }\n\n        $encodedImage = $this->imageManager->make($file->getStream())->resize(64, 64, function ($constraint) {\n            $constraint->aspectRatio();\n            $constraint->upsize();\n        })->encode('png');\n\n        $this->fileExtension = 'png';\n\n        return $encodedImage;\n    }\n}\n</Code>\n\nFile: framework/core/src/Api/Controller/UploadLogoController.php\nContent: \n<Code>\n<?php\n\n/*\n * This file is part of Flarum.\n *\n * For detailed copyright and license information, please view the\n * LICENSE file that was distributed with this source code.\n */\n\nnamespace Flarum\\Api\\Controller;\n\nuse Flarum\\Settings\\SettingsRepositoryInterface;\nuse Illuminate\\Contracts\\Filesystem\\Factory;\nuse Intervention\\Image\\Image;\nuse Intervention\\Image\\ImageManager;\nuse Psr\\Http\\Message\\UploadedFileInterface;\n\nclass UploadLogoController extends UploadImageController\n{\n    protected $filePathSettingKey = 'logo_path';\n\n    protected $filenamePrefix = 'logo';\n\n    /**\n     * @var ImageManager\n     */\n    protected $imageManager;\n\n    public function __construct(SettingsRepositoryInterface $settings, Factory $filesystemFactory, ImageManager $imageManager)\n    {\n        parent::__construct($settings, $filesystemFactory);\n\n        $this->imageManager = $imageManager;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function makeImage(UploadedFileInterface $file): Image\n    {\n        $encodedImage = $this->imageManager->make($file->getStream())->heighten(60, function ($constraint) {\n            $constraint->upsize();\n        })->encode('png');\n\n        return $encodedImage;\n    }\n}\n</Code>\n\nFile: framework/core/src/User/AvatarValidator.php\nContent: \n<Code>\n<?php\n\n/*\n * This file is part of Flarum.\n *\n * For detailed copyright and license information, please view the\n * LICENSE file that was distributed with this source code.\n */\n\nnamespace Flarum\\User;\n\nuse Flarum\\Foundation\\AbstractValidator;\nuse Flarum\\Foundation\\ValidationException;\nuse Illuminate\\Validation\\Factory;\nuse Intervention\\Image\\Exception\\NotReadableException;\nuse Intervention\\Image\\ImageManager;\nuse Psr\\Http\\Message\\UploadedFileInterface;\nuse Symfony\\Component\\Mime\\MimeTypes;\nuse Symfony\\Contracts\\Translation\\TranslatorInterface;\n\nclass AvatarValidator extends AbstractValidator\n{\n    /**\n     * @var \\Illuminate\\Validation\\Validator\n     */\n    protected $laravelValidator;\n\n    /**\n     * @var ImageManager\n     */\n    protected $imageManager;\n\n    public function __construct(Factory $validator, TranslatorInterface $translator, ImageManager $imageManager)\n    {\n        parent::__construct($validator, $translator);\n\n        $this->imageManager = $imageManager;\n    }\n\n    /**\n     * Throw an exception if a model is not valid.\n     *\n     * @param array $attributes\n     */\n    public function assertValid(array $attributes)\n    {\n        $this->laravelValidator = $this->makeValidator($attributes);\n\n        $this->assertFileRequired($attributes['avatar']);\n        $this->assertFileMimes($attributes['avatar']);\n        $this->assertFileSize($attributes['avatar']);\n    }\n\n    protected function assertFileRequired(UploadedFileInterface $file)\n    {\n        $error = $file->getError();\n\n        if ($error !== UPLOAD_ERR_OK) {\n            if ($error === UPLOAD_ERR_INI_SIZE || $error === UPLOAD_ERR_FORM_SIZE) {\n                $this->raise('file_too_large');\n            }\n\n            if ($error === UPLOAD_ERR_NO_FILE) {\n                $this->raise('required');\n            }\n\n            $this->raise('file_upload_failed');\n        }\n    }\n\n    protected function assertFileMimes(UploadedFileInterface $file)\n    {\n        $allowedTypes = $this->getAllowedTypes();\n\n        // Block PHP files masquerading as images\n        $phpExtensions = ['php', 'php3', 'php4', 'php5', 'phtml'];\n        $fileExtension = pathinfo($file->getClientFilename(), PATHINFO_EXTENSION);\n\n        if (in_array(trim(strtolower($fileExtension)), $phpExtensions)) {\n            $this->raise('mimes', [':values' => implode(', ', $allowedTypes)]);\n        }\n\n        $guessedExtension = MimeTypes::getDefault()->getExtensions($file->getClientMediaType())[0] ?? null;\n\n        if (! in_array($guessedExtension, $allowedTypes)) {\n            $this->raise('mimes', [':values' => implode(', ', $allowedTypes)]);\n        }\n\n        try {\n            $this->imageManager->make($file->getStream());\n        } catch (NotReadableException $_e) {\n            $this->raise('image');\n        }\n    }\n\n    protected function assertFileSize(UploadedFileInterface $file)\n    {\n        $maxSize = $this->getMaxSize();\n\n        if ($file->getSize() / 1024 > $maxSize) {\n            $this->raise('max.file', [':max' => $maxSize], 'max');\n        }\n    }\n\n    protected function raise($error, array $parameters = [], $rule = null)\n    {\n        // When we switched to intl ICU message format, the translation parameters\n        // have become required to be in the format `{param}`.\n        // Therefore we cannot use the translator to replace the string params.\n        // We use the laravel validator to make the replacements instead.\n        $message = $this->laravelValidator->makeReplacements(\n            $this->translator->trans(\"validation.$error\"),\n            'avatar',\n            $rule ?? $error,\n            array_values($parameters)\n        );\n\n        throw new ValidationException(['avatar' => $message]);\n    }\n\n    protected function getMaxSize()\n    {\n        return 2048;\n    }\n\n    protected function getAllowedTypes()\n    {\n        return ['jpeg', 'jpg', 'png', 'bmp', 'gif'];\n    }\n}\n</Code>\n\nFile: framework/core/src/User/Command/UploadAvatarHandler.php\nContent: \n<Code>\n<?php\n\n/*\n * This file is part of Flarum.\n *\n * For detailed copyright and license information, please view the\n * LICENSE file that was distributed with this source code.\n */\n\nnamespace Flarum\\User\\Command;\n\nuse Flarum\\Foundation\\DispatchEventsTrait;\nuse Flarum\\User\\AvatarUploader;\nuse Flarum\\User\\AvatarValidator;\nuse Flarum\\User\\Event\\AvatarSaving;\nuse Flarum\\User\\UserRepository;\nuse Illuminate\\Contracts\\Events\\Dispatcher;\nuse Intervention\\Image\\ImageManager;\n\nclass UploadAvatarHandler\n{\n    use DispatchEventsTrait;\n\n    /**\n     * @var \\Flarum\\User\\UserRepository\n     */\n    protected $users;\n\n    /**\n     * @var AvatarUploader\n     */\n    protected $uploader;\n\n    /**\n     * @var \\Flarum\\User\\AvatarValidator\n     */\n    protected $validator;\n\n    /**\n     * @var ImageManager\n     */\n    protected $imageManager;\n\n    /**\n     * @param Dispatcher $events\n     * @param UserRepository $users\n     * @param AvatarUploader $uploader\n     * @param AvatarValidator $validator\n     */\n    public function __construct(Dispatcher $events, UserRepository $users, AvatarUploader $uploader, AvatarValidator $validator, ImageManager $imageManager)\n    {\n        $this->events = $events;\n        $this->users = $users;\n        $this->uploader = $uploader;\n        $this->validator = $validator;\n        $this->imageManager = $imageManager;\n    }\n\n    /**\n     * @param UploadAvatar $command\n     * @return \\Flarum\\User\\User\n     * @throws \\Flarum\\User\\Exception\\PermissionDeniedException\n     * @throws \\Flarum\\Foundation\\ValidationException\n     */\n    public function handle(UploadAvatar $command)\n    {\n        $actor = $command->actor;\n\n        $user = $this->users->findOrFail($command->userId);\n\n        if ($actor->id !== $user->id) {\n            $actor->assertCan('edit', $user);\n        }\n\n        $this->validator->assertValid(['avatar' => $command->file]);\n\n        $image = $this->imageManager->make($command->file->getStream());\n\n        $this->events->dispatch(\n            new AvatarSaving($user, $actor, $image)\n        );\n\n        $this->uploader->upload($user, $image);\n\n        $user->save();\n\n        $this->dispatchEventsFor($user, $actor);\n\n        return $user;\n    }\n}\n</Code>\n\n"
                }
            ],
            "llm_raw_output": "{\n  \"CWE_IDS\": [\"CWE-200\", \"CWE-601\"],\n  \"severity\": \"medium\"\n}",
            "llm_output": {
                "CWE_IDS": [
                    "CWE-200",
                    "CWE-601"
                ],
                "severity": "medium"
            },
            "ground_truth_CVE": "CVE-2023-40033",
            "ground_truth_CWEs": [
                "CWE-918"
            ],
            "ground_truth_severities": {
                "V3.1": "HIGH"
            },
            "ground_truth_CVSS_version": [
                "V3.1"
            ],
            "is_equal": false,
            "error_msg": null,
            "equal_severity": false,
            "cwe_evaluation": "NOT_OVERLAPPED"
        }
    ]
}